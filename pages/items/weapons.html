<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Weapons - Project Rogue Codex</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <base href="../../" />
    <link rel="icon" type="image/x-icon" href="images/project-rogue-favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="images/project-rogue-favicon-32.png" />
    <link rel="icon" type="image/png" sizes="64x64" href="images/project-rogue-favicon-64.png" />
    <link rel="icon" type="image/png" sizes="180x180" href="images/project-rogue-favicon-180.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="images/project-rogue-favicon-512.png" />
    <link rel="stylesheet" href="css/styles.css" />
    <script src="js/utils.js"></script>
    <script src="js/site-search.js" defer></script>
    <script src="js/weapon-specialty.js" defer></script>
    <script src="js/stat-widgets.js" defer></script>
    <script src="js/keyword-links.js" defer></script>
    <script src="js/cursor-toggle.js" defer></script>
    <script src="js/perks.js" defer></script>
    <script src="js/rarity-roller.js" defer></script>
    <script src="js/nav-core.js" defer></script>
    <style>
      .item-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
        margin-bottom: 1rem;
      }

      .item-search {
        padding: 0.55rem 0.75rem;
        border: 1px solid var(--border-soft);
        border-radius: 6px;
        background: var(--bg-panel-dark);
        color: var(--text-main);
        width: min(420px, 100%);
      }

      .item-count {
        margin: 0;
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .item-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin: 0 0 0.5rem;
      }

      .item-filter {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        min-width: 220px;
      }

      .filter-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted);
        margin: 0;
      }

      .filter-select {
        background: var(--bg-panel-dark);
        color: var(--text-main);
        border: 1px solid var(--border-soft);
        border-radius: 6px;
        padding: 0.35rem 0.45rem;
        min-height: 120px;
        max-height: 180px;
        overflow: auto;
      }

      .filter-select:focus-visible {
        outline: 1px solid var(--accent);
      }

      .filter-select::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      .filter-select::-webkit-scrollbar-track {
        background: #0d1118;
        border-radius: 8px;
      }

      .filter-select::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #3a414f, #262c36);
        border: 1px solid var(--border-soft);
        border-radius: 8px;
        box-shadow: inset 0 0 0 1px #0b0f16;
      }

      .filter-select::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, #4a5262, #2f3642);
      }

      .items-table-wrapper {
        overflow: visible;
        border: 1px solid var(--border-soft);
        border-radius: 8px;
        background: var(--bg-panel);
        box-shadow: 0 0 0 1px #0b0f16, 0 8px 16px rgba(0, 0, 0, 0.55);
      }

      .items-table {
        width: 100%;
        border-collapse: collapse;
        min-width: 640px;
        border: 1px solid var(--border-soft);
        box-shadow: 0 0 0 1px #0b0f16, 0 8px 16px rgba(0, 0, 0, 0.55);
      }

      .items-table thead {
        background: linear-gradient(to bottom, #303540, #252a33);
        position: sticky;
        top: 0;
        z-index: 3;
      }

      .items-table th,
      .items-table td {
        padding: 0.55rem 0.75rem;
        text-align: left;
        border-bottom: 1px solid #2f333b;
        font-size: 0.92rem;
      }

      .items-table th {
        background: linear-gradient(to bottom, #303540, #252a33);
        position: sticky;
        top: 0;
        z-index: 2;
        cursor: pointer;
        user-select: none;
        letter-spacing: 0.02em;
        color: #f9fafb;
        white-space: nowrap;
      }

      .items-table th .sort-indicator {
        margin-left: 0.35rem;
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .items-table tbody tr {
        background: var(--bg-panel-dark);
      }

      .items-table tbody tr:nth-child(2n) {
        background: #1d222b;
      }

      .items-table tbody tr:hover {
        background: rgba(75, 255, 75, 0.08);
        cursor: pointer;
      }

      .item-thumb {
        width: 32px;
        height: 32px;
        object-fit: cover;
        border-radius: 6px;
        border: 1px solid var(--border-soft);
        background: #0f1218;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }

      .no-image {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 32px;
        min-height: 32px;
        padding: 0.2rem 0.35rem;
        border: 1px solid var(--border-soft);
        border-radius: 6px;
        background: #0f1218;
        color: var(--text-muted);
        font-size: 0.82rem;
        text-align: center;
      }

      .no-image-fallback {
        width: 32px;
        height: 32px;
        display: none;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border-soft);
        border-radius: 6px;
        background: #0f1218;
        color: var(--text-muted);
        font-size: 0.82rem;
        text-align: center;
      }

      .item-details {
        display: none;
        border: 1px solid var(--border-soft);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        background: linear-gradient(135deg, #20252e, #141821);
        box-shadow: 0 0 0 1px #0b0f16, 0 12px 22px rgba(0, 0, 0, 0.65);
      }

      .item-details.show {
        display: block;
      }

      .item-details-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        margin-bottom: 0.6rem;
        flex-wrap: wrap;
      }

      .item-details-body {
        display: block;
      }

      .item-title-group {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .item-details .item-thumb {
        width: 64px;
        height: 64px;
      }

      .item-details .no-image-fallback {
        width: 64px;
        height: 64px;
      }

      .details-button,
      .details-close {
        border: 1px solid var(--border-soft);
        background: linear-gradient(135deg, rgba(50, 60, 75, 0.9), rgba(20, 24, 32, 0.9));
        color: var(--text-main);
        padding: 0.45rem 0.9rem;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.15s ease, transform 0.1s ease;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-weight: 600;
        letter-spacing: 0.02em;
        line-height: 1.2;
        min-height: 2.35rem;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
      }

      .details-button:hover,
      .details-close:hover {
        background: linear-gradient(135deg, rgba(60, 72, 88, 0.95), rgba(26, 30, 40, 0.95));
        transform: translateY(-1px);
      }

      .table-empty {
        text-align: center;
        padding: 1rem;
        color: var(--text-muted);
      }

      .item-details::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      .item-details::-webkit-scrollbar-track {
        background: #0d1118;
        border-radius: 8px;
      }

      .item-details::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #3a414f, #262c36);
        border: 1px solid var(--border-soft);
        border-radius: 8px;
        box-shadow: inset 0 0 0 1px #0b0f16;
      }

      .item-details-grid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 0.5rem 1rem;
      }

      .detail-cell {
        padding: 0.3rem 0;
      }

      .detail-row {
        display: grid;
        gap: 0.5rem 0.75rem;
        margin-bottom: 0.35rem;
        grid-column: 1 / -1;
      }

      .detail-row-cols-1 {
        grid-template-columns: 1fr;
      }

      .detail-row-cols-2 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .detail-row-cols-3 {
        grid-template-columns: repeat(3, minmax(140px, 1fr));
      }

      .detail-row-cols-4 {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }

      .detail-row-cols-5 {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }

      .detail-label {
        font-size: 0.78rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted);
        margin: 0 0 0.1rem;
        display: block;
      }

      .detail-value {
        font-weight: 700;
        color: #fff;
      }

      .detail-divider {
        grid-column: 1 / -1;
        height: 1px;
        margin: 0.35rem 0 0.25rem;
        background: var(--border-soft);
        opacity: 0.6;
      }

      .detail-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        padding: 0.2rem 0.65rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: linear-gradient(135deg, rgba(44, 50, 64, 0.9), rgba(28, 33, 43, 0.9));
        color: #e8ecf2;
        font-weight: 700;
        letter-spacing: 0.03em;
        position: relative;
      }

      .detail-pill:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .detail-tooltip-row {
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        font-size: 0.85rem;
        color: var(--text-main);
        align-items: center;
        white-space: nowrap;
      }

      .detail-tooltip-label {
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.04em;
        font-size: 0.76rem;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
      }

      .detail-tooltip-type {
        color: var(--text-muted);
        font-weight: 600;
        font-size: 0.85rem;
        letter-spacing: normal;
        text-transform: none;
      }

      .detail-tooltip a {
        color: inherit;
        text-decoration: none;
      }

      .detail-tooltip a:hover,
      .detail-tooltip a:focus-visible {
        text-decoration: underline;
      }

      .detail-tooltip-divider {
        height: 1px;
        background: var(--border-soft);
        opacity: 0.65;
        margin: 0.25rem 0;
      }

      .detail-pill .detail-tooltip {
        position: absolute;
        left: 0;
        top: 110%;
        margin-top: 0.1rem;
        padding: 0.4rem 0.55rem;
        border-radius: 6px;
        background: #11151c;
        border: 1px solid var(--border-soft);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
        display: none;
        min-width: 220px;
        width: max-content;
        max-height: 320px;
        overflow: auto;
        white-space: nowrap;
        z-index: 5;
      }

      .detail-pill:hover .detail-tooltip,
      .detail-pill:focus-within .detail-tooltip {
        display: block;
      }

      .detail-tooltip.is-pinned {
        display: block;
      }

      .detail-tooltip.perk-tooltip {
        white-space: normal;
        min-width: 260px;
        max-width: min(520px, 70vw);
        line-height: 1.3;
      }

      .perk-tooltip-title {
        font-weight: 800;
        color: #ffffff;
        margin-bottom: 0.25rem;
      }

      .perk-tooltip-line {
        font-weight: 400;
        color: var(--text-main);
        white-space: normal;
      }

      @media (max-width: 640px) {
        .item-details-grid {
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div id="sidebar-root"></div>
      <main class="main-content">
        <header class="content-header">
          <h1 class="content-title">Weapons</h1>
        </header>

        <section class="item-details" id="item-details" aria-live="polite">
          <div class="item-details-header">
            <div class="item-title-group">
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <img id="details-image" class="item-thumb" alt="" />
                <div id="details-image-fallback" class="no-image-fallback">No Image</div>
              </div>
              <h2 id="details-name" class="content-title" style="margin: 0"></h2>
            </div>
            <button type="button" class="details-button details-close" id="details-close">Close</button>
          </div>
          <div class="item-details-body">
            <div id="details-properties" class="item-details-grid"></div>
          </div>
        </section>

        <div class="content-section">
          <div class="item-controls">
            <input
              type="search"
              id="item-search"
              class="item-search"
              placeholder="Search weapons by any field..."
              aria-label="Search weapons"
            />
            <p class="item-count" id="item-count"></p>
          </div>

          <div class="item-filters" aria-label="Filters">
            <div class="item-filter">
              <label class="filter-label" for="filter-type">Type</label>
              <select id="filter-type" class="filter-select" multiple aria-label="Filter by type"></select>
            </div>
            <div class="item-filter">
              <label class="filter-label" for="filter-element">Element</label>
              <select id="filter-element" class="filter-select" multiple aria-label="Filter by element"></select>
            </div>
          </div>

          <div class="items-table-wrapper">
            <table class="items-table" aria-describedby="item-search">
              <thead>
                <tr id="items-head-row"></tr>
              </thead>
              <tbody id="items-body"></tbody>
            </table>
          </div>
        </div>
      </main>
    </div>


    <script>
      (() => {
        const PAGE = {
          title: "Weapons",
          dataFile: "weapons_data05.json",
        };

        const WEAPONS_SCHEMA_VERSION = 5;
        const dataUrl = (() => {
          const resolved = new URL(PAGE.dataFile, window.location.href);
          if (resolved.protocol === "http:" || resolved.protocol === "https:") {
            resolved.searchParams.set("v", String(WEAPONS_SCHEMA_VERSION));
          }
          return resolved;
        })();
        const searchInput = document.getElementById("item-search");
        const typeFilter = document.getElementById("filter-type");
        const elementFilter = document.getElementById("filter-element");
        const tableHeadRow = document.getElementById("items-head-row");
        const tableBody = document.getElementById("items-body");
        const countLabel = document.getElementById("item-count");
        const details = document.getElementById("item-details");
        const closeBtn = document.getElementById("details-close");

        const detailFields = {
          name: document.getElementById("details-name"),
          image: document.getElementById("details-image"),
          imageFallback: document.getElementById("details-image-fallback"),
          properties: document.getElementById("details-properties"),
        };

        const utils = window.RogueCodexUtils || {};
        const fetchJsonCached =
          utils.fetchJsonCached ||
          ((targetUrl) =>
            fetch(targetUrl)
              .then((res) => (res.ok ? res.json() : null))
              .catch(() => null));
        const normalizeFilterValue =
          utils.normalizeFilterValue || ((value) => (value || "").toString().trim().toLowerCase());
        const ELEMENT_COLORS = utils.ELEMENT_COLORS || {};
        const getElementColor =
          utils.getElementColor || ((value) => ELEMENT_COLORS[normalizeFilterValue(value)] || "");
        const createElementBadge =
          utils.createElementBadge ||
          ((value) => {
            const span = document.createElement("span");
            span.textContent = formatValue(value);
            const color = getElementColor(value);
            if (color) span.style.color = color;
            return span;
          });
        const createPerkBadge =
          utils.createPerkBadge ||
          ((value) => {
            const span = document.createElement("span");
            span.textContent = formatValue(value);
            return span;
          });
        const getPerkTierColor = utils.getPerkTierColor || (() => "");

        const RESISTANCE_LABELS = {
          fire: "Fire Resistance",
          cold: "Cold Resistance",
          electric: "Electric Resistance",
          acid: "Acid Resistance",
          poison: "Poison Resistance",
          disease: "Disease Resistance",
        };

        const STAT_LABELS = {
          strength: "Strength",
          dexterity: "Dexterity",
          constitution: "Constitution",
        };

        const RESISTANCES_SCHEMA_VERSION = 1;
        const MONSTER_TYPE_ORDER = [
          "humanoid",
          "giant",
          "animal",
          "beast",
          "undead",
          "demon",
          "fire beast",
          "ice beast",
          "electric beast",
          "poison beast",
          "disease beast",
        ];
        let typeResistances = {};
        const resistancesUrl = (() => {
          try {
            const resolved = new URL("../systems/resistances.json", window.location.href);
            if (resolved.protocol === "http:" || resolved.protocol === "https:") {
              resolved.searchParams.set("v", String(RESISTANCES_SCHEMA_VERSION));
            }
            return resolved.toString();
          } catch (error) {
            return "../systems/resistances.json";
          }
        })();

        const PERKS_SCHEMA_VERSION = 3;
        let perkIndexByName = new Map();
        const perksUrl = (() => {
          try {
            const resolved = new URL("../systems/perks.json", window.location.href);
            if (resolved.protocol === "http:" || resolved.protocol === "https:") {
              resolved.searchParams.set("v", String(PERKS_SCHEMA_VERSION));
            }
            return resolved.toString();
          } catch (error) {
            return "../systems/perks.json";
          }
        })();

        const MONSTERS_SCHEMA_VERSION = 3;
        const monstersUrl = (() => {
          try {
            const resolved = new URL("../enemies/monsters_data03.json", window.location.href);
            if (resolved.protocol === "http:" || resolved.protocol === "https:") {
              resolved.searchParams.set("v", String(MONSTERS_SCHEMA_VERSION));
            }
            return resolved.toString();
          } catch (error) {
            return "../enemies/monsters_data03.json";
          }
        })();

        const HIDDEN_NAMES = new Set(
          [
            "Super Super Blunt",
            "Super Duper Pole",
            "Super Duper",
            "Super Duper Blunt",
            "Super Duper Axe",
            "GM Deathbringer",
            "Ghostblade",
            "Wand of the Winds",
            "Wand of the Flames",
            "Tooth Staff",
            "Krythan Staff",
            "Bone Staff",
            "Staff of Might",
            "Cursed Staff",
            "Vengeance Sword",
          ].map((name) => name.toLowerCase())
        );

        const UNIQUE_WEAPON_DROP_SOURCES = {
          "rune sword": ["rune-warrior", "balron", "demon-lord"],
          "vengeance hammer": ["banished-knight", "banished-warden"],
        };

        const ALLOWED_MONSTER_NAMES = new Set(
          [
            "Abishai",
            "Anubis",
            "Balron",
            "Banished Knight",
            "Banished Soldier",
            "Banished Spirit",
            "Banished Warden",
            "Bat",
            "Beholder",
            "Black Dragon",
            "Blightscale",
            "Blue Dragon",
            "Blue Wisp",
            "Brown Triddle",
            "Centaur",
            "Centaur Warrior",
            "Cinderdrake",
            "Crawling Defiler",
            "Cryoblade Revenant",
            "Cyclops",
            "Dark Druid",
            "Dark Mage",
            "Dark Monk",
            "Death",
            "Death Skull",
            "Death Tyrant",
            "Demon",
            "Demon Lord",
            "Demon Spire",
            "Dirt Demon",
            "Dretch",
            "Dretch Lord",
            "Drowned Skull",
            "Dune Lord",
            "Dusk Mage",
            "Duskwyrm",
            "Ettin",
            "Evil Eye",
            "Fighter",
            "Flaming Death",
            "Floating Horror",
            "Frost Giant",
            "Frost Troll",
            "Funguilla",
            "Gas Spore",
            "Ghost",
            "Glutton",
            "Glutton Shaman",
            "Glutton Slave",
            "Golem",
            "Greater Oglah",
            "Greater Troll",
            "Greater Yeti",
            "Green Dragon",
            "Green Slime",
            "Green Triddle",
            "Grimbark",
            "Harpy",
            "Headless",
            "Hell Hound",
            "Hell Spawn",
            "Hellbinder",
            "Hellfiend",
            "Hells Warden",
            "Hivemind",
            "Hobgoblin",
            "Horned Devil",
            "Hydra",
            "Ice Devil",
            "Ice Dragon",
            "Ice Golem",
            "Icehand",
            "Ilithid",
            "Imp",
            "Infernal",
            "Juggernaut",
            "Kobold",
            "Kobold Mage",
            "Large Slime",
            "Lava Beast",
            "Lesser Lich",
            "Lich",
            "Lizardman",
            "Master of Frost",
            "Master Orc",
            "Medusa",
            "Minion",
            "Minotaur",
            "Mossy Golem",
            "Nelm",
            "Night Hag",
            "Nightmare",
            "Nycadaemon",
            "Oglah",
            "Oglah Soldier",
            "Orc",
            "Orc General",
            "Orc Shaman",
            "Orc Warrior",
            "Orc Wizard",
            "Orcling",
            "Orcus",
            "Phantom",
            "Phoenix",
            "Pirate",
            "Pirate Captain",
            "Purple Wisp",
            "Red Dragon",
            "Red Druid",
            "Red Wisp",
            "Risen Dead",
            "Risen Frost",
            "Rock Troll",
            "Rune Warrior",
            "Scorpotaur",
            "Shriek",
            "Skeleton",
            "Skeleton Warrior",
            "Skeleton Wolf",
            "Snake",
            "Snow Terror",
            "Sparkscale",
            "Specter",
            "Spider",
            "Stone Giant",
            "Stone Golem",
            "Stone Goliath",
            "Storm Giant",
            "Swashbuckler",
            "Thief",
            "Toxic Bat",
            "Toxic Skull",
            "Toxincoil",
            "Triddle",
            "Undead Knight",
            "Undead Priest",
            "Undead Warrior",
            "Vampire Bat",
            "Venomdrake",
            "Voltling",
            "Werewolf",
            "Wraith",
            "Wyrmling",
            "Yeti",
            "Zombie",
          ].map((name) => name.toLowerCase())
        );

        const COLUMNS = [
          { key: "image", label: "Image", render: (_, item) => createImageThumb(item), sortable: false },
          { key: "name", label: "Name" },
          { key: "type", label: "Type" },
          { key: "level", label: "Level", format: (value) => formatNumber(value) },
          { key: "dps", label: "DPS", format: (value) => formatNumber(value, { maximumFractionDigits: 2 }) },
          { key: "perk", label: "Perk", render: (value) => createPerkBadge(value) },
          { key: "element", label: "Element", render: (value) => createElementBadge(value) },
        ];

        let items = [];
        let monsters = [];
        let selectedTypes = new Set();
        let selectedElements = new Set();
        let sortKey = "dps";
        let sortDir = "desc";
        let searchTerm = "";
        const urlParams = new URLSearchParams(window.location.search);
        const normalizeWeaponId = (value) =>
          (value || "")
            .toString()
            .toLowerCase()
            .replace(/[^a-z0-9_-]+/g, "-")
            .replace(/^-+|-+$/g, "");
        const normalizeMonsterId = (value) =>
          (value || "")
            .toString()
            .toLowerCase()
            .replace(/[^a-z0-9_-]+/g, "-")
            .replace(/^-+|-+$/g, "");
        const rawWeaponQuery = (urlParams.get("weapon") || urlParams.get("weaponName") || "").trim();
        const initialWeaponId = normalizeWeaponId(rawWeaponQuery);
        const initialWeaponSearchTerm = rawWeaponQuery.replace(/-/g, " ").trim();
        let pendingWeaponId = initialWeaponId;
        let pendingWeaponName = rawWeaponQuery.toLowerCase();

        const renderEmpty = (message) => {
          if (!tableHeadRow.children.length) {
            buildHead();
          }
          tableBody.innerHTML = `<tr><td class="table-empty" colspan="${COLUMNS.length || 1}">${message}</td></tr>`;
          if (countLabel) {
            countLabel.textContent = "0 results";
          }
        };

        const normalizeSortValue = (value) => {
          if (value === null || value === undefined) return "";
          if (typeof value === "number") return value;
          if (typeof value === "boolean") return value ? 1 : 0;
          if (Array.isArray(value)) return value.join(", ");
          if (typeof value === "object") return JSON.stringify(value);
          return String(value).toLowerCase();
        };

        const formatValue = (value) => {
          if (value === null || value === undefined || value === "") return "-";
          if (Array.isArray(value)) return value.join(", ");
          if (typeof value === "object") return JSON.stringify(value);
          return value;
        };

        const formatNumber = (value, options = {}) => {
          if (value === null || value === undefined || value === "") return "-";
          const num = Number(value);
          if (Number.isNaN(num)) return value;
          return num.toLocaleString("en-US", { maximumFractionDigits: 0, ...options });
        };

        const formatRange = (min, max) => {
          const hasMin = min !== null && min !== undefined && min !== "";
          const hasMax = max !== null && max !== undefined && max !== "";
          if (hasMin && hasMax) return `${formatNumber(min)} - ${formatNumber(max)}`;
          if (hasMin) return `${formatNumber(min)}`;
          if (hasMax) return `${formatNumber(max)}`;
          return "-";
        };

        const ELEMENT_KEYS_WITH_MULTIPLIERS = new Set(["fire", "cold", "electric", "poison", "disease", "acid"]);

        const formatMonsterTypeLabel = (value) => {
          if (!value) return "-";
          return String(value)
            .replace(/([a-z])([A-Z])/g, "$1 $2")
            .replace(/[_]+/g, " ")
            .replace(/\b\w/g, (c) => c.toUpperCase());
        };

        const formatMultiplierValue = (value) => {
          if (typeof value !== "number" || Number.isNaN(value)) return "-";
          if (Number.isInteger(value)) return `${value}x`;
          let text = value.toString();
          if (text.startsWith("0.")) {
            text = text.replace(/^0+/, "");
          } else if (text.startsWith("-0.")) {
            text = text.replace(/^-0+/, "-.");
          }
          text = text.replace(/(\.\d*?)0+$/, "$1");
          if (text.endsWith(".")) text = text.slice(0, -1);
          return `${text}x`;
        };

        const getMultiplierColor = (value) => {
          if (typeof value !== "number" || Number.isNaN(value)) return "";
          if (value > 1) {
            const ratio = Math.min((value - 1) / 0.3, 1);
            const lightness = 50 + 20 * ratio;
            const saturation = 65 + 15 * ratio;
            return `hsl(120, ${saturation}%, ${lightness}%)`;
          }
          if (value < 1) {
            const ratio = Math.min((1 - value) / 0.3, 1);
            const lightness = 55 + 25 * ratio;
            return `hsl(0, 80%, ${lightness}%)`;
          }
          return "#bbbbbb";
        };

        const extractPerkBaseName = (value) => {
          const raw = (value || "").toString().trim();
          if (!raw || raw === "-" || raw.toLowerCase() === "none") return "";
          return raw
            .replace(/\s*\(\s*tier\s*\d+\s*\)\s*$/i, "")
            .replace(/\s*\(\s*t\s*\d+\s*\)\s*$/i, "")
            .replace(/\s*tier\s*\d+\s*$/i, "")
            .replace(/\s*t\s*\d+\s*$/i, "")
            .trim();
        };

        const createPerkDetailPill = (value) => {
          const labelText = formatValue(value);
          const baseName = extractPerkBaseName(value);
          if (!labelText || labelText === "-" || !baseName) {
            return createPerkBadge(value);
          }

          const pill = document.createElement("span");
          pill.className = "detail-pill";
          pill.tabIndex = 0;
          pill.setAttribute("aria-label", `${labelText} perk details`);

          const labelSpan = document.createElement("span");
          labelSpan.textContent = labelText;
          const color = getPerkTierColor(value);
          if (color) labelSpan.style.color = color;
          pill.appendChild(labelSpan);

          const tooltip = document.createElement("span");
          tooltip.className = "detail-tooltip perk-tooltip";
          tooltip.role = "tooltip";

          const entry = perkIndexByName.get(baseName.toLowerCase());
          const detailsLines = Array.isArray(entry?.details)
            ? entry.details.map((line) => String(line || "").trim()).filter(Boolean)
            : [];

          const title = document.createElement("div");
          title.className = "perk-tooltip-title";
          title.textContent = labelText;
          tooltip.appendChild(title);

          if (detailsLines.length) {
            const divider = document.createElement("div");
            divider.className = "detail-tooltip-divider";
            tooltip.appendChild(divider);

            detailsLines.forEach((line) => {
              const div = document.createElement("div");
              div.className = "perk-tooltip-line";
              div.textContent = line;
              tooltip.appendChild(div);
            });
          } else {
            const line = document.createElement("div");
            line.className = "perk-tooltip-line";
            line.textContent = "Perk info unavailable.";
            tooltip.appendChild(line);
          }

          pill.appendChild(tooltip);
          return pill;
        };

        const getElementMultiplierForType = (monsterTypeKey, elementKey) => {
          const list = typeResistances && typeof typeResistances === "object" ? typeResistances[monsterTypeKey] : null;
          if (!Array.isArray(list) || !list.length) return 1;
          const match = list.find((entry) => normalizeFilterValue(entry?.element) === elementKey);
          return typeof match?.value === "number" ? match.value : 1;
        };

        const createElementEffectivenessPill = (value) => {
          const labelText = formatValue(value);
          const elementKey = normalizeFilterValue(value);
          if (!labelText || labelText === "-" || elementKey === "none" || elementKey === "magic") {
            return createElementBadge(value);
          }
          if (!ELEMENT_KEYS_WITH_MULTIPLIERS.has(elementKey)) {
            return createElementBadge(value);
          }

          const pill = document.createElement("span");
          pill.className = "detail-pill";
          pill.tabIndex = 0;
          pill.setAttribute("aria-label", `${labelText} effectiveness by monster type`);

          const labelSpan = document.createElement("span");
          labelSpan.textContent = labelText;
          const color = getElementColor(value);
          if (color) labelSpan.style.color = color;
          pill.appendChild(labelSpan);

          const tooltip = document.createElement("span");
          tooltip.className = "detail-tooltip";
          tooltip.role = "tooltip";

          const hasData =
            typeResistances && typeof typeResistances === "object" && Object.keys(typeResistances).length > 0;
          if (!hasData) {
            tooltip.textContent = "No modifier data";
          } else {
            const headerRow = document.createElement("div");
            headerRow.className = "detail-tooltip-row";
            const headerLeft = document.createElement("span");
            headerLeft.className = "detail-tooltip-label";
            headerLeft.textContent = "Monster Type";
            const headerRight = document.createElement("span");
            headerRight.className = "detail-tooltip-label";
            headerRight.textContent = "Damage";
            headerRow.appendChild(headerLeft);
            headerRow.appendChild(headerRight);
            tooltip.appendChild(headerRow);

            const divider = document.createElement("div");
            divider.className = "detail-tooltip-divider";
            tooltip.appendChild(divider);

            const rows = MONSTER_TYPE_ORDER.map((monsterTypeKey, idx) => ({
              monsterTypeKey,
              multiplier: getElementMultiplierForType(monsterTypeKey, elementKey),
              idx,
            })).sort((a, b) => {
              if (b.multiplier !== a.multiplier) return b.multiplier - a.multiplier;
              return a.idx - b.idx;
            });

            const firstNeutral = rows.findIndex((row) => row.multiplier === 1 || row.multiplier === 1.0);
            const lastNeutral = (() => {
              let idx = -1;
              rows.forEach((row, i) => {
                if (row.multiplier === 1 || row.multiplier === 1.0) idx = i;
              });
              return idx;
            })();

            rows.forEach(({ monsterTypeKey, multiplier }, index) => {
              if (index === firstNeutral && index !== 0) {
                const groupDivider = document.createElement("div");
                groupDivider.className = "detail-tooltip-divider";
                tooltip.appendChild(groupDivider);
              }

              const row = document.createElement("div");
              row.className = "detail-tooltip-row";
              const typeLabel = document.createElement("span");
              typeLabel.className = "detail-tooltip-type";
              typeLabel.textContent = formatMonsterTypeLabel(monsterTypeKey);
              const valueSpan = document.createElement("span");
              valueSpan.textContent = formatMultiplierValue(multiplier);
              if (typeof multiplier === "number") {
                const valColor = getMultiplierColor(multiplier);
                if (valColor) valueSpan.style.color = valColor;
              }
              row.appendChild(typeLabel);
              row.appendChild(valueSpan);
              tooltip.appendChild(row);

              if (index === lastNeutral && index !== rows.length - 1) {
                const groupDivider = document.createElement("div");
                groupDivider.className = "detail-tooltip-divider";
                tooltip.appendChild(groupDivider);
              }
            });
          }

          pill.appendChild(tooltip);
          return pill;
        };

        const getMonsterDropRange = (monsterLevel) => {
          const level = Number(monsterLevel);
          if (!Number.isFinite(level)) return null;
          return {
            level,
            min: Math.max(0, level - 5),
            max: level + 5,
          };
        };

        const createDropsFromPill = (item) => {
          const pill = document.createElement("span");
          pill.className = "detail-pill";
          pill.textContent = "Monsters";
          pill.tabIndex = 0;
          pill.setAttribute("aria-label", "Monsters that drop this item");

          const tooltip = document.createElement("span");
          tooltip.className = "detail-tooltip";
          tooltip.role = "tooltip";

            if (!Array.isArray(monsters) || !monsters.length) {
              tooltip.textContent = "No monster data loaded";
            } else {
              const itemLevel = Number(item?.level);
              const uniqueMonsterIds = UNIQUE_WEAPON_DROP_SOURCES[normalizeFilterValue(item?.name)] || null;
              const useUnique = Array.isArray(uniqueMonsterIds) && uniqueMonsterIds.length > 0;
              if (!useUnique && !Number.isFinite(itemLevel)) {
                tooltip.textContent = "No level data";
              } else {
                const uniqueSet = useUnique ? new Set(uniqueMonsterIds.map((id) => normalizeMonsterId(id))) : null;
                const list = monsters
                  .map((monster) => {
                    const monsterId = normalizeMonsterId(monster.name || monster.id);
                    if (useUnique) {
                      if (!uniqueSet.has(monsterId)) return null;
                    } else {
                      const range = getMonsterDropRange(monster.level);
                      if (!range) return null;
                      if (itemLevel < range.min || itemLevel > range.max) return null;
                    }
                    const typeRaw = monster.monsterType || "";
                    const levelValue = Number(monster.level);
                    return {
                      id: monsterId,
                      name: monster.name || "Unknown Monster",
                      type: typeRaw,
                      typeKey: normalizeFilterValue(typeRaw) || "unknown",
                      level: Number.isFinite(levelValue) ? levelValue : null,
                    };
                  })
                  .filter(Boolean)
                  .sort((a, b) => {
                    if (a.typeKey !== b.typeKey) return a.typeKey.localeCompare(b.typeKey);
                    const levelA = Number.isFinite(a.level) ? a.level : -Infinity;
                    const levelB = Number.isFinite(b.level) ? b.level : -Infinity;
                    if (levelB !== levelA) return levelB - levelA;
                    return a.name.localeCompare(b.name);
                  });

              const headerRow = document.createElement("div");
              headerRow.className = "detail-tooltip-row";
              const nameLabel = document.createElement("span");
              nameLabel.className = "detail-tooltip-label";
              nameLabel.textContent = "Name";
              const typeLabel = document.createElement("span");
              typeLabel.className = "detail-tooltip-label";
              typeLabel.textContent = "Type";
              headerRow.appendChild(nameLabel);
              headerRow.appendChild(typeLabel);
              tooltip.appendChild(headerRow);

              const divider = document.createElement("div");
              divider.className = "detail-tooltip-divider";
              tooltip.appendChild(divider);

                if (!list.length) {
                  const emptyRow = document.createElement("div");
                  emptyRow.className = "detail-tooltip-row";
                  const emptyLabel = document.createElement("span");
                  emptyLabel.className = "detail-tooltip-label";
                  emptyLabel.textContent = "No monsters in range";
                  emptyRow.appendChild(emptyLabel);
                  tooltip.appendChild(emptyRow);
                } else {
                  let lastTypeKey = null;
                  list.forEach((entry) => {
                    if (lastTypeKey && entry.typeKey !== lastTypeKey) {
                      const groupDivider = document.createElement("div");
                      groupDivider.className = "detail-tooltip-divider";
                      tooltip.appendChild(groupDivider);
                    }
                    lastTypeKey = entry.typeKey;

                    const row = document.createElement("div");
                    row.className = "detail-tooltip-row";
                    const nameLink = document.createElement("a");
                    nameLink.textContent = entry.name;
                    nameLink.href = `pages/enemies/monsters.html?monster=${encodeURIComponent(entry.id)}`;
                    const typeSpan = document.createElement("span");
                    typeSpan.className = "detail-tooltip-type";
                    typeSpan.textContent = formatMonsterTypeLabel(entry.type);
                    row.appendChild(nameLink);
                    row.appendChild(typeSpan);
                    tooltip.appendChild(row);
                  });
                }
              }
            }

          pill.appendChild(tooltip);
          return pill;
        };

        const setOptions = (select, options) => {
          if (!select) return;
          select.innerHTML = "";
          options.forEach(({ value, label }) => {
            const opt = document.createElement("option");
            opt.value = value;
            opt.textContent = label;
            select.appendChild(opt);
          });
        };

        const enableToggleSelect = (selectEl) => {
          if (!selectEl) return;
          selectEl.addEventListener("mousedown", (event) => {
            const option = event.target;
            if (option && option.tagName === "OPTION") {
              event.preventDefault();
              option.selected = !option.selected;
              selectEl.dispatchEvent(new Event("change", { bubbles: true }));
            }
          });
        };

        const imageManifestCache = new Map();
        const loadImageManifest = (folder) => {
          if (imageManifestCache.has(folder)) return imageManifestCache.get(folder);
          const map = new Map();
          imageManifestCache.set(folder, map);
          fetch(`images/${folder}/manifest.json`)
            .then((res) => (res.ok ? res.json() : Promise.reject()))
            .then((list) => {
              const entries = Array.isArray(list) ? list : [];
              entries.forEach((path) => {
                const file = String(path || "").split("/").pop() || "";
                const base = file.replace(/\.[^.]+$/, "").toLowerCase();
                if (base) map.set(base, path);
              });
            })
            .catch(() => {});
          return map;
        };

        loadImageManifest("weapons");

        const deriveImageCandidates = (item, folder = "weapons") => {
          const candidates = [];
          const direct = typeof item === "string" ? item : item && item.image;
          if (direct) candidates.push(direct);
          const name = (item && (item.name || item.Name || item.id)) || "";
          const trimmed = String(name).trim();
          const lower = trimmed.toLowerCase();
          const manifest = imageManifestCache.get(folder);
          if (manifest && lower && manifest.has(lower)) {
            candidates.push(manifest.get(lower));
          }
          if (trimmed) {
            const encoded = encodeURIComponent(trimmed);
            candidates.push(`images/${folder}/${encoded}.gif`, `images/${folder}/${encoded}.png`);
          }
          return Array.from(new Set(candidates.filter(Boolean)));
        };

        const ensureImage = (img, fallback, item, folder = "weapons") => {
          if (!img || !fallback) return;
          fallback.style.display = "none";
          const sources = deriveImageCandidates(item, folder);
          if (!sources.length) {
            img.style.display = "none";
            fallback.style.display = "flex";
            return;
          }
          let index = 0;
          const trySet = () => {
            img.onload = () => {
              img.style.display = "block";
              fallback.style.display = "none";
            };
            img.onerror = () => {
              index += 1;
              if (index < sources.length) {
                trySet();
              } else {
                img.style.display = "none";
                fallback.style.display = "flex";
              }
            };
            img.src = sources[index];
          };
          trySet();
        };

        const createCell = (labelContent, valueContent) => {
          const cell = document.createElement("div");
          cell.className = "detail-cell";
          const label = document.createElement("span");
          label.className = "detail-label";
          if (labelContent instanceof Node) {
            label.appendChild(labelContent);
          } else {
            label.textContent = labelContent;
          }
          const value = document.createElement("div");
          value.className = "detail-value";
          if (valueContent instanceof Node) {
            value.appendChild(valueContent);
          } else {
            value.textContent = valueContent;
          }
          cell.appendChild(label);
          cell.appendChild(value);
          return cell;
        };

        const createPill = (items) => {
          const pill = document.createElement("span");
          pill.className = "flag-pill";
          pill.textContent = items.length ? items.join(", ") : "None";
          return pill;
        };

        const createImageThumb = (item) => {
          const wrapper = document.createElement("div");
          wrapper.style.display = "inline-flex";
          wrapper.style.alignItems = "center";
          const img = document.createElement("img");
          img.className = "item-thumb";
          img.alt = `${item.name || "Item"} image`;
          const fallback = document.createElement("span");
          fallback.className = "no-image";
          fallback.textContent = "No Image";
          ensureImage(img, fallback, item);
          wrapper.appendChild(img);
          wrapper.appendChild(fallback);
          return wrapper;
        };

        const populateFilters = (data) => {
          const typeOptions = new Map();
          const elementOptions = new Set();

          data.forEach((w) => {
            const typeValue = normalizeFilterValue(w.type);
            if (typeValue) {
              if (!typeOptions.has(typeValue)) {
                typeOptions.set(typeValue, String(w.type));
              }
            }
            const elementValue = normalizeFilterValue(w.element);
            if (elementValue && elementValue !== "none" && elementValue !== "magic") {
              elementOptions.add(String(w.element));
            }
          });

          const typeList = Array.from(typeOptions.entries())
            .sort((a, b) => a[1].localeCompare(b[1]))
            .map(([value, label]) => ({ value, label }));
          const elementList = Array.from(elementOptions)
            .sort((a, b) => a.localeCompare(b))
            .map((value) => ({ value: normalizeFilterValue(value), label: value }));

          setOptions(typeFilter, typeList);
          setOptions(elementFilter, elementList);
          if (elementFilter) {
            Array.from(elementFilter.options).forEach((opt) => {
              const color = getElementColor(opt.value);
              if (color) {
                opt.style.color = color;
              }
            });
          }
        };

        const computeDps = (minDamage, maxDamage, attackSpeed) => {
          const min = Number(minDamage);
          const max = Number(maxDamage);
          const speed = Number(attackSpeed);
          if (Number.isNaN(min) || Number.isNaN(max) || Number.isNaN(speed) || speed === 0) return null;
          const avgDamage = (min + max) / 2;
          return Number((avgDamage * (1000 / speed)).toFixed(2));
        };

        const buildRarity = (fields) => {
          const max = fields.max_rarity_label || fields.max_rarity;
          const maxLabel = max === null || max === undefined || max === "" ? "-" : max;
          return `Regular - ${maxLabel}`;
        };

        const normalizeWeapon = (raw) => {
          const fields = (raw && typeof raw.fields === "object" && raw.fields) || {};
          const value = fields.value;
          const sellValue =
            value === null || value === undefined || value === ""
              ? null
              : Number.isNaN(Number(value))
                ? null
                : Number(value) / 2;

          return {
            id: raw && (raw.id ?? raw.ID) ? raw.id ?? raw.ID : normalizeWeaponId(raw && (raw.name || raw.Name)),
            name: (raw && (raw.name || raw.Name)) || "Unknown",
            image: raw && (raw.image || raw.icon || raw.thumbnail) ? raw.image || raw.icon || raw.thumbnail : "",
            level: fields.level_requirement,
            minDamage: fields.min_damage,
            maxDamage: fields.max_damage,
            attackSpeed: fields.attack_speed,
            dps: computeDps(fields.min_damage, fields.max_damage, fields.attack_speed),
            type: fields.subtype_label || fields.subtype,
            perk: fields.perk ? fields.perk_label || fields.perk : "None",
            element: fields.element_label || (fields.element ? fields.element : "None"),
            procChance: fields.proc_chance,
            skillRequirement: fields.skill_requirement,
            weight: fields.weight,
            specialty: fields.specialty ? fields.specialty_label || fields.specialty : "None",
            specialtyAmount: fields.specialty_amount,
            rarity: buildRarity(fields),
            maxRarityLabel: fields.max_rarity_label || fields.max_rarity,
            toHit: fields.to_hit,
            value,
            sellValue,
            shardDecompositionAmount: fields.shard_decomposition_amount,
            shardPromotionAmount: fields.shard_promotion_amount,
            resistances: {
              fire: fields.fire_resistance,
              cold: fields.cold_resistance,
              electric: fields.electric_resistance,
              acid: fields.acid_resistance,
              poison: fields.poison_resistance,
              disease: fields.disease_resistance,
            },
            stats: {
              strength: fields.strength,
              dexterity: fields.dexterity,
              constitution: fields.constitution,
              },
            };
        };

        const normalizeMonster = (raw) => {
          if (!raw || typeof raw !== "object") return null;
          const fields = (raw && typeof raw.fields === "object" && raw.fields) || {};
          const nameRaw = raw.name || raw.Name || fields.name_label || "Unknown Monster";
          const monsterTypeRaw = fields.type_label || raw.monsterType || raw.type || raw.type_label || "";
          const level = Number(fields.level ?? raw.level ?? raw.Level);
          const idRaw = raw.id ?? raw.monsterId ?? raw.name ?? raw.Name ?? fields.name_label ?? "";
          const id = normalizeMonsterId(idRaw || nameRaw);
          return {
            id,
            name: nameRaw ? String(nameRaw) : "Unknown Monster",
            monsterType: monsterTypeRaw === null || monsterTypeRaw === undefined ? "" : String(monsterTypeRaw),
            level: Number.isFinite(level) ? level : null,
          };
        };

        const normalizeMonsters = (list) => {
          if (!Array.isArray(list)) return [];
          return list
            .map((entry) => normalizeMonster(entry))
            .filter(Boolean)
            .filter((monster) => ALLOWED_MONSTER_NAMES.has((monster.name || "").toLowerCase()));
        };

        const getWeaponId = (item) => normalizeWeaponId(item && (item.id || item.name));

        const maybeSelectPendingWeapon = (list) => {
          if (!pendingWeaponId && !pendingWeaponName) return;
          const match = (list || items).find((w) => {
            const id = getWeaponId(w);
            const nameLower = (w.name || "").toLowerCase();
            return (pendingWeaponId && id === pendingWeaponId) || (pendingWeaponName && nameLower === pendingWeaponName);
          });
          if (!match) return;
          pendingWeaponId = "";
          pendingWeaponName = "";
          setDetails(match);
        };

        const updateSortIndicators = () => {
          document.querySelectorAll(".items-table th[data-sort-key]").forEach((th) => {
            const key = th.getAttribute("data-sort-key");
            const indicator = th.querySelector(".sort-indicator");
            const isActive = key === sortKey;
            const ariaSort = isActive ? (sortDir === "asc" ? "ascending" : "descending") : "none";
            th.setAttribute("aria-sort", ariaSort);
            if (indicator) {
              indicator.textContent = isActive ? (sortDir === "asc" ? "\u25B2" : "\u25BC") : "\u2195";
            }
          });
        };

        const buildHead = () => {
          tableHeadRow.innerHTML = "";
          COLUMNS.forEach((col) => {
            const th = document.createElement("th");
            th.setAttribute("scope", "col");

            const labelSpan = document.createElement("span");
            labelSpan.textContent = col.label;
            th.appendChild(labelSpan);

            if (col.sortable !== false) {
              th.dataset.sortKey = col.key;
              const indicator = document.createElement("span");
              indicator.className = "sort-indicator";
              indicator.setAttribute("aria-hidden", "true");
              indicator.textContent = "\u2195";
              th.appendChild(indicator);

              th.addEventListener("click", () => {
                if (sortKey === col.key) {
                  sortDir = sortDir === "asc" ? "desc" : "asc";
                } else {
                  sortKey = col.key;
                  sortDir = "asc";
                }
                applyFilterAndSort();
              });
            } else {
              th.style.cursor = "default";
            }

            tableHeadRow.appendChild(th);
          });
          updateSortIndicators();
        };

        let pinnedTooltip = null;
        let pinDocumentListenerAttached = false;

        function unpinTooltip(tooltip) {
          if (!tooltip) return;
          tooltip.classList.remove("is-pinned");
          if (pinnedTooltip === tooltip) pinnedTooltip = null;
        }

        function attachTooltipPinning(root) {
          const scope = root || document;
          const tooltips = scope.querySelectorAll(".detail-pill .detail-tooltip");
          tooltips.forEach((tooltip) => {
            if (!tooltip || tooltip.dataset.pinWired === "1") return;
            const pill = tooltip.closest(".detail-pill");
            if (!pill) return;

            const toggle = (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (pinnedTooltip && pinnedTooltip !== tooltip) {
                unpinTooltip(pinnedTooltip);
              }
              if (tooltip.classList.contains("is-pinned")) {
                unpinTooltip(tooltip);
              } else {
                tooltip.classList.add("is-pinned");
                pinnedTooltip = tooltip;
              }
            };

            pill.addEventListener("click", toggle);
            pill.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                toggle(event);
              }
            });
            tooltip.addEventListener("click", (event) => event.stopPropagation());
            tooltip.dataset.pinWired = "1";
          });

          if (!pinDocumentListenerAttached) {
            pinDocumentListenerAttached = true;
            document.addEventListener("click", (event) => {
              if (!pinnedTooltip) return;
              const pill = pinnedTooltip.closest(".detail-pill");
              if (pill && pill.contains(event.target)) return;
              unpinTooltip(pinnedTooltip);
            });
            document.addEventListener("keydown", (event) => {
              if (event.key !== "Escape") return;
              if (!pinnedTooltip) return;
              unpinTooltip(pinnedTooltip);
            });
          }
        }

        const setDetails = (item) => {
          if (!item) return;
          detailFields.name.textContent = item.name || "Unknown";
          ensureImage(detailFields.image, detailFields.imageFallback, item);
          if (pinnedTooltip) unpinTooltip(pinnedTooltip);

          const container = detailFields.properties;
          container.innerHTML = "";

          const addDivider = () =>
            container.appendChild(Object.assign(document.createElement("div"), { className: "detail-divider" }));
          const addRow = (entries, cols) => {
            const row = document.createElement("div");
            row.className = `detail-row detail-row-cols-${cols || 2}`;
            entries.forEach(([label, value]) => row.appendChild(createCell(label, value)));
            container.appendChild(row);
          };

          addRow(
            [
              ["Type", formatValue(item.type)],
              ["Level", formatNumber(item.level)],
              ["DPS", formatNumber(item.dps, { maximumFractionDigits: 2 })],
              ["Weight", formatNumber(item.weight)],
              ["To Hit", formatNumber(item.toHit)],
            ],
            5
          );
          addRow(
            [
              ["Element", createElementEffectivenessPill(item.element)],
              [
                "Proc",
                item.procChance === null || item.procChance === undefined || item.procChance === ""
                  ? "-"
                  : `${formatNumber(item.procChance, { maximumFractionDigits: 2 })}%`,
              ],
              ["Damage", formatRange(item.minDamage, item.maxDamage)],
              ["Specialty", formatValue(item.specialty)],
              ["Specialty Amount", formatNumber(item.specialtyAmount)],
            ],
            5
          );

          addDivider();

          addRow(
            [
              ["Strength", formatNumber((item.stats && item.stats.strength) ?? 0)],
              ["Constitution", formatNumber((item.stats && item.stats.constitution) ?? 0)],
              ["Dexterity", formatNumber((item.stats && item.stats.dexterity) ?? 0)],
            ],
            3
          );

          addDivider();

          const res = item.resistances || {};
          const makeResistEntry = (key, labelText, rawValue) => {
            const color = ELEMENT_COLORS[key];
            const labelSpan = document.createElement("span");
            labelSpan.textContent = labelText;
            if (color) labelSpan.style.color = color;
            const valueSpan = document.createElement("span");
            valueSpan.textContent = formatNumber(rawValue ?? 0);
            if (color) valueSpan.style.color = color;
            return [labelSpan, valueSpan];
          };
          addRow(
            [
              makeResistEntry("fire", "Fire", res.fire),
              makeResistEntry("poison", "Poison", res.poison),
              makeResistEntry("cold", "Cold", res.cold),
            ],
            3
          );
          addRow(
            [
              makeResistEntry("disease", "Disease", res.disease),
              makeResistEntry("acid", "Acid", res.acid),
              makeResistEntry("electric", "Electric", res.electric),
            ],
            3
          );

          addDivider();

          addRow([["Innate Perk", createPerkDetailPill(item.perk)]], 1);

          addDivider();

          addRow(
            [
              ["Max Rarity", formatValue(item.maxRarityLabel || item.rarity)],
              ["Promotion", formatNumber(item.shardPromotionAmount)],
              ["Deconstruction", formatNumber(item.shardDecompositionAmount)],
            ],
            3
          );

          addDivider();

          addRow([["Requirement", `Skill Level ${formatNumber(item.skillRequirement)}`]], 1);

          addDivider();

          addRow([["Drops From", createDropsFromPill(item)]], 1);

          addDivider();

          addRow(
            [
              ["Value", formatNumber(item.value)],
              ["Sell Value", formatNumber(item.sellValue, { maximumFractionDigits: 2 })],
            ],
            2
          );

          attachTooltipPinning(details);
          details.classList.add("show");
          details.scrollIntoView({ behavior: "smooth", block: "start" });
        };

        const clearDetails = () => {
          details.classList.remove("show");
          if (pinnedTooltip) unpinTooltip(pinnedTooltip);
        };

        const renderTable = (rows) => {
          if (!rows.length) {
            renderEmpty("No weapons match your filters.");
            return;
          }

          const fragment = document.createDocumentFragment();

          rows.forEach((item) => {
            const tr = document.createElement("tr");
            tr.dataset.id = item.id || "";

            COLUMNS.forEach((col) => {
              const td = document.createElement("td");
              const value = item[col.key];
              if (col.render) {
                const rendered = col.render(value, item);
                if (rendered instanceof Node) {
                  td.appendChild(rendered);
                } else {
                  td.textContent = formatValue(rendered);
                }
              } else if (col.format) {
                td.textContent = col.format(value);
              } else {
                td.textContent = formatValue(value);
              }
              tr.appendChild(td);
            });

            tr.addEventListener("click", () => setDetails(item));
            fragment.appendChild(tr);
          });

          tableBody.innerHTML = "";
          tableBody.appendChild(fragment);
        };

        const applyFilterAndSort = () => {
          if (!Array.isArray(items) || !items.length) {
            renderEmpty("No weapons found in weapons_data05.json.");
            return;
          }

          const searchableColumns = COLUMNS.map((c) => c.key);

          const filtered = items.filter((item) => {
            const matchesType = selectedTypes.size === 0 || selectedTypes.has(normalizeFilterValue(item.type));
            const matchesElement =
              selectedElements.size === 0 || selectedElements.has(normalizeFilterValue(item.element));
            if (!matchesType || !matchesElement) return false;
            if (!searchTerm) return true;
            const text = searchableColumns
              .map((col) => formatValue(item[col]))
              .join(" ")
              .toLowerCase();
            return text.includes(searchTerm.toLowerCase());
          });

          const sorted = filtered.sort((a, b) => {
            const av = normalizeSortValue(a[sortKey]);
            const bv = normalizeSortValue(b[sortKey]);
            if (av < bv) return sortDir === "asc" ? -1 : 1;
            if (av > bv) return sortDir === "asc" ? 1 : -1;
            return 0;
          });

          updateSortIndicators();

          if (countLabel) {
            const count = sorted.length;
            countLabel.textContent = `${count} result${count === 1 ? "" : "s"}`;
          }

          renderTable(sorted);
          maybeSelectPendingWeapon(sorted);
        };

        const init = () => {
          Promise.all([
            fetchJsonCached(dataUrl.toString()),
            fetchJsonCached(resistancesUrl),
            fetchJsonCached(perksUrl),
            fetchJsonCached(monstersUrl),
          ])
            .then(([data, resistancesData, perksData, monstersData]) => {
              const map = resistancesData && typeof resistancesData === "object" ? resistancesData.typeResistances : null;
              if (map && typeof map === "object") {
                typeResistances = map;
              }
              const perks = Array.isArray(perksData?.perks) ? perksData.perks : [];
              perkIndexByName = new Map();
              perks.forEach((entry) => {
                const name = entry && typeof entry.name === "string" ? entry.name.trim() : "";
                if (!name) return;
                perkIndexByName.set(name.toLowerCase(), entry);
              });
              monsters = normalizeMonsters(Array.isArray(monstersData) ? monstersData : []);
              items = (Array.isArray(data) ? data : [])
                .map((row) => normalizeWeapon(row))
                .filter((weapon) => {
                  const nameLower = (weapon.name || "").toLowerCase();
                  const levelNum = Number(weapon.level);
                  if (nameLower === "flaming sword" && levelNum === 0) return false;
                  return !HIDDEN_NAMES.has(nameLower);
                });
              if (!items.length) {
                renderEmpty("Add weapons_data05.json beside this page to see weapons.");
                return;
              }
              sortKey = "dps";
              sortDir = "desc";
              selectedTypes = new Set();
              selectedElements = new Set();
              buildHead();
              populateFilters(items);
              if (initialWeaponSearchTerm) {
                searchTerm = initialWeaponSearchTerm;
                if (searchInput) searchInput.value = initialWeaponSearchTerm;
              }
              applyFilterAndSort();
            })
            .catch(() => {
              renderEmpty("Unable to load weapons. Add weapons_data05.json beside this page.");
            });
        };

        if (searchInput) {
          searchInput.addEventListener("input", (event) => {
            searchTerm = event.target.value || "";
            applyFilterAndSort();
          });
        }

        if (typeFilter) {
          enableToggleSelect(typeFilter);
          typeFilter.addEventListener("change", () => {
            selectedTypes = new Set(Array.from(typeFilter.selectedOptions).map((o) => o.value));
            applyFilterAndSort();
          });
        }

        if (elementFilter) {
          enableToggleSelect(elementFilter);
          elementFilter.addEventListener("change", () => {
            selectedElements = new Set(Array.from(elementFilter.selectedOptions).map((o) => o.value));
            applyFilterAndSort();
          });
        }

        if (closeBtn) {
          closeBtn.addEventListener("click", clearDetails);
        }

        init();
      })();
    </script>

  </body>
</html>
