<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Armors - Project Rogue Codex</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <base href="../../" />
    <link rel="icon" type="image/x-icon" href="images/project-rogue-favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="images/project-rogue-favicon-32.png" />
    <link rel="icon" type="image/png" sizes="64x64" href="images/project-rogue-favicon-64.png" />
    <link rel="icon" type="image/png" sizes="180x180" href="images/project-rogue-favicon-180.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="images/project-rogue-favicon-512.png" />
    <link rel="stylesheet" href="css/styles.css" />
    <script src="js/utils.js"></script>
    <script src="js/site-search.js" defer></script>
    <script src="js/weapon-specialty.js" defer></script>
    <script src="js/stat-widgets.js" defer></script>
    <script src="js/keyword-links.js" defer></script>
    <script src="js/cursor-toggle.js" defer></script>
    <script src="js/perks.js" defer></script>
    <script src="js/rarity-roller.js" defer></script>
    <script src="js/nav-core.js" defer></script>
    <style>
      .item-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
        margin-bottom: 1rem;
      }

      .item-search {
        padding: 0.55rem 0.75rem;
        border: 1px solid var(--border-soft);
        border-radius: 6px;
        background: var(--bg-panel-dark);
        color: var(--text-main);
        width: min(420px, 100%);
      }

      .item-count {
        margin: 0;
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .items-table-wrapper {
        overflow: visible;
        border: 1px solid var(--border-soft);
        border-radius: 8px;
        background: var(--bg-panel);
        box-shadow: 0 0 0 1px #0b0f16, 0 8px 16px rgba(0, 0, 0, 0.55);
      }

      .items-table {
        width: 100%;
        border-collapse: collapse;
        min-width: 640px;
      }

      .items-table thead {
        background: linear-gradient(to bottom, #303540, #252a33);
        position: sticky;
        top: 0;
        z-index: 3;
      }

      .items-table th,
      .items-table td {
        padding: 0.55rem 0.75rem;
        text-align: left;
        border-bottom: 1px solid #2f333b;
        font-size: 0.92rem;
      }

      .items-table th {
        background: linear-gradient(to bottom, #303540, #252a33);
        position: sticky;
        top: 0;
        z-index: 2;
        cursor: pointer;
        user-select: none;
        letter-spacing: 0.02em;
        color: #f9fafb;
        white-space: nowrap;
      }

      .items-table th .sort-indicator {
        margin-left: 0.35rem;
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .items-table tbody tr {
        background: var(--bg-panel-dark);
      }

      .items-table tbody tr:nth-child(2n) {
        background: #1d222b;
      }

      .items-table tbody tr:hover {
        background: rgba(75, 255, 75, 0.08);
        cursor: pointer;
      }

      .item-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin: 0 0 0.5rem;
      }

      .item-filter {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        min-width: 220px;
      }

      .filter-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted);
        margin: 0;
      }

      .filter-select {
        background: var(--bg-panel-dark);
        color: var(--text-main);
        border: 1px solid var(--border-soft);
        border-radius: 6px;
        padding: 0.35rem 0.45rem;
        min-height: 120px;
        max-height: 180px;
        overflow: auto;
      }

      .filter-select:focus-visible {
        outline: 1px solid var(--accent);
      }

      .filter-select::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      .filter-select::-webkit-scrollbar-track {
        background: #0d1118;
        border-radius: 8px;
      }

      .filter-select::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #3a414f, #262c36);
        border: 1px solid var(--border-soft);
        border-radius: 8px;
        box-shadow: inset 0 0 0 1px #0b0f16;
      }

      .filter-select::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, #4a5262, #2f3642);
      }

      .item-thumb {
        width: 32px;
        height: 32px;
        object-fit: cover;
        border-radius: 6px;
        border: 1px solid var(--border-soft);
        background: #0f1218;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
      }

      .no-image {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 32px;
        min-height: 32px;
        padding: 0.2rem 0.35rem;
        border: 1px solid var(--border-soft);
        border-radius: 6px;
        background: #0f1218;
        color: var(--text-muted);
        font-size: 0.82rem;
        text-align: center;
      }

      .no-image-fallback {
        width: 32px;
        height: 32px;
        display: none;
        align-items: center;
        justify-content: center;
        border: 1px solid var(--border-soft);
        border-radius: 6px;
        background: #0f1218;
        color: var(--text-muted);
        font-size: 0.82rem;
        text-align: center;
      }

      .item-details {
        display: none;
        border: 1px solid var(--border-soft);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
        background: linear-gradient(135deg, #20252e, #141821);
        box-shadow: 0 0 0 1px #0b0f16, 0 12px 22px rgba(0, 0, 0, 0.65);
      }

      .item-details.show {
        display: block;
      }

      .item-details-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        margin-bottom: 0.6rem;
        flex-wrap: wrap;
      }

      .item-details-body {
        display: block;
      }

      .item-title-group {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .item-details .item-thumb {
        width: 64px;
        height: 64px;
      }

      .item-details .no-image-fallback {
        width: 64px;
        height: 64px;
      }

      .details-button,
      .details-close {
        border: 1px solid var(--border-soft);
        background: linear-gradient(135deg, rgba(50, 60, 75, 0.9), rgba(20, 24, 32, 0.9));
        color: var(--text-main);
        padding: 0.45rem 0.9rem;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.15s ease, transform 0.1s ease;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-weight: 600;
        letter-spacing: 0.02em;
        line-height: 1.2;
        min-height: 2.35rem;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
      }

      .details-button:hover,
      .details-close:hover {
        background: linear-gradient(135deg, rgba(60, 72, 88, 0.95), rgba(26, 30, 40, 0.95));
        transform: translateY(-1px);
      }

      .table-empty {
        text-align: center;
        padding: 1rem;
        color: var(--text-muted);
      }

      .items-table-wrapper::-webkit-scrollbar,
      .item-details::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }

      .items-table-wrapper::-webkit-scrollbar-track,
      .item-details::-webkit-scrollbar-track {
        background: #0d1118;
        border-radius: 8px;
      }

      .items-table-wrapper::-webkit-scrollbar-thumb,
      .item-details::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #3a414f, #262c36);
        border: 1px solid var(--border-soft);
        border-radius: 8px;
        box-shadow: inset 0 0 0 1px #0b0f16;
      }

      .item-details-grid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 0.5rem 1rem;
      }

      .detail-cell {
        padding: 0.3rem 0;
      }

      .detail-divider {
        grid-column: 1 / -1;
        height: 1px;
        margin: 0.35rem 0 0.25rem;
        background: var(--border-soft);
        opacity: 0.6;
      }

      .detail-row {
        display: grid;
        gap: 0.5rem 0.75rem;
        margin-bottom: 0.35rem;
        grid-column: 1 / -1;
      }

      .detail-row-cols-1 {
        grid-template-columns: 1fr;
      }

      .detail-row-cols-2 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .detail-row-cols-3 {
        grid-template-columns: repeat(3, minmax(140px, 1fr));
      }

      .detail-row-cols-4 {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }

      .detail-row-cols-5 {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }

      .detail-label {
        font-size: 0.78rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted);
        margin: 0 0 0.1rem;
        display: block;
      }

      .detail-value {
        font-weight: 700;
        color: #fff;
      }

      .detail-pill {
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        padding: 0.2rem 0.65rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: linear-gradient(135deg, rgba(44, 50, 64, 0.9), rgba(28, 33, 43, 0.9));
        color: #e8ecf2;
        font-weight: 700;
        letter-spacing: 0.03em;
        position: relative;
      }

      .detail-pill:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      .detail-tooltip-row {
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        font-size: 0.85rem;
        color: var(--text-main);
        align-items: center;
        white-space: nowrap;
      }

      .detail-tooltip-label {
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.04em;
        font-size: 0.76rem;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
      }

      .detail-tooltip-type {
        color: var(--text-muted);
        font-weight: 600;
        font-size: 0.85rem;
        letter-spacing: normal;
        text-transform: none;
      }

      .detail-tooltip a {
        color: inherit;
        text-decoration: none;
      }

      .detail-tooltip a:hover,
      .detail-tooltip a:focus-visible {
        text-decoration: underline;
      }

      .detail-tooltip-divider {
        height: 1px;
        background: var(--border-soft);
        opacity: 0.65;
        margin: 0.25rem 0;
      }

      .detail-pill .detail-tooltip {
        position: absolute;
        left: 0;
        top: 110%;
        margin-top: 0.1rem;
        padding: 0.4rem 0.55rem;
        border-radius: 6px;
        background: #11151c;
        border: 1px solid var(--border-soft);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
        display: none;
        min-width: 220px;
        width: max-content;
        max-height: 320px;
        overflow: auto;
        white-space: nowrap;
        z-index: 5;
      }

      .detail-pill:hover .detail-tooltip,
      .detail-pill:focus-within .detail-tooltip {
        display: block;
      }

      .detail-tooltip.is-pinned {
        display: block;
      }

      .detail-tooltip.perk-tooltip {
        white-space: normal;
        min-width: 260px;
        max-width: min(520px, 70vw);
        line-height: 1.3;
      }

      .perk-tooltip-title {
        font-weight: 800;
        color: #ffffff;
        margin-bottom: 0.25rem;
      }

      .perk-tooltip-line {
        font-weight: 400;
        color: var(--text-main);
        white-space: normal;
      }

      @media (max-width: 640px) {
        .item-details-grid {
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        }
      }
    </style>
  </head>
  <body>
    <div class="layout">
      <div id="sidebar-root"></div>
      <main class="main-content">
        <header class="content-header">
          <h1 class="content-title">Armors</h1>
        </header>

        <section class="item-details" id="item-details" aria-live="polite">
          <div class="item-details-header">
            <div class="item-title-group">
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <img id="details-image" class="item-thumb" alt="" />
                <div id="details-image-fallback" class="no-image-fallback">No Image</div>
              </div>
              <h2 id="details-name" class="content-title" style="margin: 0"></h2>
            </div>
            <button type="button" class="details-button details-close" id="details-close">Close</button>
          </div>
          <div class="item-details-body">
            <div id="details-properties" class="item-details-grid"></div>
          </div>
        </section>

        <div class="content-section">
          <div class="item-controls">
            <input
              type="search"
              id="item-search"
              class="item-search"
              placeholder="Search armors by any field..."
              aria-label="Search armors"
            />
            <p class="item-count" id="item-count"></p>
          </div>

          <div class="item-filters" aria-label="Filters">
            <div class="item-filter">
              <label class="filter-label" for="filter-slot">Slot</label>
              <select id="filter-slot" class="filter-select" multiple aria-label="Filter by slot"></select>
            </div>
            <div class="item-filter">
              <label class="filter-label" for="filter-resist">Resistances</label>
              <select id="filter-resist" class="filter-select" multiple aria-label="Filter by resistance"></select>
            </div>
          </div>

          <div class="items-table-wrapper">
            <table class="items-table" aria-describedby="item-search">
              <thead>
                <tr id="items-head-row"></tr>
              </thead>
              <tbody id="items-body"></tbody>
            </table>
          </div>
        </div>
      </main>
    </div>

    <script>
      (() => {
        const PAGE = {
          title: "Armors",
          dataFile: "armors_data06.json",
        };

        const dataUrl = new URL(PAGE.dataFile, window.location.href);
        const searchInput = document.getElementById("item-search");
        const slotFilter = document.getElementById("filter-slot");
        const resistFilter = document.getElementById("filter-resist");
        const urlParams = new URLSearchParams(window.location.search);
        const initialArmorQuery = (urlParams.get("armor") || urlParams.get("armorName") || "").trim();
        const initialArmorSearchTerm = initialArmorQuery.replace(/-/g, " ").trim();
        let pendingArmorName = initialArmorQuery.toLowerCase();
        const tableHeadRow = document.getElementById("items-head-row");
        const tableBody = document.getElementById("items-body");
        const countLabel = document.getElementById("item-count");
        const details = document.getElementById("item-details");
        const closeBtn = document.getElementById("details-close");

        const detailFields = {
          name: document.getElementById("details-name"),
          image: document.getElementById("details-image"),
          imageFallback: document.getElementById("details-image-fallback"),
          properties: document.getElementById("details-properties"),
        };

        const utils = window.RogueCodexUtils || {};
        const fetchJsonCached =
          utils.fetchJsonCached ||
          ((targetUrl) =>
            fetch(targetUrl)
              .then((res) => (res.ok ? res.json() : null))
              .catch(() => null));
        const normalizeFilterValue =
          utils.normalizeFilterValue || ((value) => (value || "").toString().trim().toLowerCase());
        const RESIST_COLORS = utils.RESIST_COLORS || {};
        const createPerkBadge =
          utils.createPerkBadge ||
          ((value) => {
            const span = document.createElement("span");
            span.textContent = formatValue(value);
            return span;
          });
        const getPerkTierColor = utils.getPerkTierColor || (() => "");

        const RARITY_MULTIPLIERS = [
          { key: "normal", label: "Normal", multiplier: 1 },
          { key: "uncommon", label: "Uncommon", multiplier: 2 },
          { key: "rare", label: "Rare", multiplier: 4 },
          { key: "epic", label: "Epic", multiplier: 6 },
          { key: "legendary", label: "Legendary", multiplier: 8 },
          { key: "mythical", label: "Mythical", multiplier: 10 },
          { key: "ascendant", label: "Ascendant", multiplier: 12 },
        ];
        const RARITY_KEY_INDEX = new Map(
          RARITY_MULTIPLIERS.map((rarity, index) => [rarity.key, index])
        );

        const getMaxRarityIndex = (maxRarity) => {
          if (maxRarity === null || maxRarity === undefined || maxRarity === "") return null;
          const numeric = Number(maxRarity);
          if (Number.isFinite(numeric)) {
            if (numeric < 0) return null;
            return Math.min(Math.floor(numeric), RARITY_MULTIPLIERS.length - 1);
          }
          let label = normalizeFilterValue(maxRarity);
          if (!label) return null;
          if (label.includes("regular")) {
            const parts = label.split("-").map((part) => part.trim());
            label = parts.length > 1 ? parts[1] : label.replace("regular", "").trim();
          }
          const labelNumber = Number(label);
          if (Number.isFinite(labelNumber)) {
            if (labelNumber < 0) return null;
            return Math.min(Math.floor(labelNumber), RARITY_MULTIPLIERS.length - 1);
          }
          if (label === "common") label = "normal";
          return RARITY_KEY_INDEX.has(label) ? RARITY_KEY_INDEX.get(label) : null;
        };

        const PERKS_SCHEMA_VERSION = 3;
        let perkIndexByName = new Map();
        const perksUrl = (() => {
          try {
            const resolved = new URL("../systems/perks.json", window.location.href);
            if (resolved.protocol === "http:" || resolved.protocol === "https:") {
              resolved.searchParams.set("v", String(PERKS_SCHEMA_VERSION));
            }
            return resolved.toString();
          } catch (error) {
            return "../systems/perks.json";
          }
        })();

        const MONSTERS_SCHEMA_VERSION = 3;
        const monstersUrl = (() => {
          try {
            const resolved = new URL("../enemies/monsters_data03.json", window.location.href);
            if (resolved.protocol === "http:" || resolved.protocol === "https:") {
              resolved.searchParams.set("v", String(MONSTERS_SCHEMA_VERSION));
            }
            return resolved.toString();
          } catch (error) {
            return "../enemies/monsters_data03.json";
          }
        })();

        const COLUMNS = [
          { key: "image", label: "Image", sortable: false },
          { key: "name", label: "Name" },
          { key: "level", label: "Level" },
          { key: "armor", label: "Armor" },
          { key: "fireResist", label: "Fire", format: (v) => formatNumber(v) },
          { key: "poisonResist", label: "Poison", format: (v) => formatNumber(v) },
          { key: "coldResist", label: "Cold", format: (v) => formatNumber(v) },
          { key: "diseaseResist", label: "Disease", format: (v) => formatNumber(v) },
          { key: "acidResist", label: "Acid", format: (v) => formatNumber(v) },
          { key: "electricResist", label: "Electric", format: (v) => formatNumber(v) },
        ];

        let items = [];
        let monsters = [];
        let sortKey = "level";
        let sortDir = "desc";
        let searchTerm = "";
        let selectedSlots = new Set();
        let selectedResists = new Set();
        const buildNameSet =
          utils.buildNameSet ||
          ((list) =>
            new Set(
              (Array.isArray(list) ? list : [])
                .map((value) => (value === null || value === undefined ? "" : String(value)).trim().toLowerCase())
                .filter(Boolean)
            ));
        const loadAllowlists =
          typeof utils.loadAllowlists === "function" ? () => utils.loadAllowlists() : () => Promise.resolve(null);
        let hiddenArmorNames = new Set();
        let allowedMonsterNames = new Set();

        const applyAllowlists = (allowlists) => {
          hiddenArmorNames = buildNameSet(allowlists?.armors?.block);
          allowedMonsterNames = buildNameSet(allowlists?.monsters?.allow);
        };

        const isMonsterAllowed = (monster) => {
          if (!allowedMonsterNames.size) return true;
          return allowedMonsterNames.has((monster.name || "").toLowerCase());
        };

        const UNIQUE_ARMOR_DROP_SOURCES = {
          "mystic robe": ["dark-monk"],
          "banished gauntlets": ["banished-spirit"],
          "banished shield": ["banished-spirit", "banished-soldier"],
          "banished platemail": ["banished-knight"],
          "banished helmet": ["banished-knight"],
          "banished leggings": ["banished-soldier"],
        };

        const titleCase = (text) =>
          text
            .replace(/([a-z])([A-Z])/g, "$1 $2")
            .replace(/[_-]+/g, " ")
            .replace(/\s+/g, " ")
            .trim()
            .replace(/\b\w/g, (c) => c.toUpperCase());

        const formatMonsterTypeLabel = (value) => {
          if (!value) return "-";
          return titleCase(String(value));
        };

        const normalizeMonsterId = (value) =>
          (value || "")
            .toString()
            .toLowerCase()
            .replace(/[^a-z0-9_-]+/g, "-")
            .replace(/^-+|-+$/g, "");

        const renderEmpty = (message) => {
          if (!tableHeadRow.children.length) {
            buildHead();
          }
          tableBody.innerHTML = `<tr><td class="table-empty" colspan="${COLUMNS.length || 1}">${message}</td></tr>`;
          if (countLabel) {
            countLabel.textContent = "0 results";
          }
        };

        const normalizeSortValue = (value) => {
          if (value === null || value === undefined) return "";
          if (typeof value === "number") return value;
          if (typeof value === "boolean") return value ? 1 : 0;
          if (Array.isArray(value)) return value.join(", ");
          if (typeof value === "object") return JSON.stringify(value);
          return String(value).toLowerCase();
        };

        const formatValue = (value) => {
          if (value === null || value === undefined) return "-";
          if (Array.isArray(value)) return value.join(", ");
          if (typeof value === "object") return JSON.stringify(value);
          return value;
        };

        const formatNumber = (value, options = {}) => {
          if (value === null || value === undefined || value === "") return "-";
          const num = Number(value);
          if (Number.isNaN(num)) return value;
          return num.toLocaleString("en-US", { maximumFractionDigits: 0, ...options });
        };

        const toNumber = (value) => {
          const num = Number(value);
          return Number.isFinite(num) ? num : null;
        };

        const setOptions = (select, options) => {
          if (!select) return;
          select.innerHTML = "";
          options.forEach(({ value, label }) => {
            const opt = document.createElement("option");
            opt.value = value;
            opt.textContent = label;
            select.appendChild(opt);
          });
        };

        const enableToggleSelect = (selectEl) => {
          if (!selectEl) return;
          selectEl.addEventListener("mousedown", (event) => {
            const option = event.target;
            if (option && option.tagName === "OPTION") {
              event.preventDefault();
              option.selected = !option.selected;
              selectEl.dispatchEvent(new Event("change", { bubbles: true }));
            }
          });
        };

        const getArmorId = (item) => (item && item.name ? item.name.toString().toLowerCase() : "");

        const createCell = (labelContent, valueContent) => {
          const cell = document.createElement("div");
          cell.className = "detail-cell";
          const label = document.createElement("span");
          label.className = "detail-label";
          if (labelContent instanceof Node) {
            label.appendChild(labelContent);
          } else {
            label.textContent = labelContent;
          }
          const value = document.createElement("div");
          value.className = "detail-value";
          if (valueContent instanceof Node) {
            value.appendChild(valueContent);
          } else {
            value.textContent = valueContent;
          }
          cell.appendChild(label);
          cell.appendChild(value);
          return cell;
        };

        const addDivider = (container) =>
          container.appendChild(Object.assign(document.createElement("div"), { className: "detail-divider" }));

        const addRow = (container, entries, cols) => {
          const row = document.createElement("div");
          row.className = `detail-row detail-row-cols-${cols || 2}`;
          entries.forEach(([label, value]) => row.appendChild(createCell(label, value)));
          container.appendChild(row);
        };

        const updateSortIndicators = () => {
          document.querySelectorAll(".items-table th[data-sort-key]").forEach((th) => {
            const key = th.getAttribute("data-sort-key");
            const indicator = th.querySelector(".sort-indicator");
            const isActive = key === sortKey;
            const ariaSort = isActive ? (sortDir === "asc" ? "ascending" : "descending") : "none";
            th.setAttribute("aria-sort", ariaSort);
            if (indicator) {
              indicator.textContent = isActive ? (sortDir === "asc" ? "\u25B2" : "\u25BC") : "\u2195";
            }
          });
        };

        const isSlotZero = (slotValue) =>
          slotValue === 0 || (typeof slotValue === "string" && slotValue.trim() === "0");

        const normalizeArmor = (raw) => {
          const fields = (raw && raw.fields) || {};
          const valueNum = toNumber(fields.value);
          return {
            id: raw && raw.id ? raw.id : (raw.name || "").toLowerCase().replace(/[^a-z0-9_-]+/g, "-"),
            name: raw.name || "Unknown",
            slot: fields.slot_label || fields.slot,
            level: fields.level,
            armor: fields.armor,
            weight: fields.weight,
            maxRarity: fields.max_rarity_label || fields.max_rarity,
            perk: fields.perk_label || (fields.perk ? fields.perk : "None"),
            corruptedPerk:
              fields.corrupted_perk_label || (fields.corrupted_perk ? fields.corrupted_perk : "None"),
            value: valueNum,
            sellValue: valueNum !== null ? valueNum / 2 : null,
            promotion: fields.promotion,
            deconstruction: fields.deconstruction,
            toHit: fields.to_hit,
            playerLevelRequirement: toNumber(fields.player_level_requirement),
            resistances: {
              fire: fields.fire_resistance,
              cold: fields.cold_resistance,
              lightning: fields.lightning_resistance,
              acid: fields.acid_resistance,
              poison: fields.poison_resistance,
              disease: fields.disease_resistance,
            },
            fireResist: fields.fire_resistance,
            poisonResist: fields.poison_resistance,
            coldResist: fields.cold_resistance,
            diseaseResist: fields.disease_resistance,
            acidResist: fields.acid_resistance,
            electricResist: fields.lightning_resistance,
            stats: {
              strength: fields.strength,
              constitution: fields.constitution,
              dexterity: fields.dexterity,
            },
          };
        };

        const normalizeMonster = (raw) => {
          if (!raw || typeof raw !== "object") return null;
          const fields = (raw && typeof raw.fields === "object" && raw.fields) || {};
          const nameRaw = raw.name || raw.Name || fields.name_label || "Unknown Monster";
          const monsterTypeRaw = fields.type_label || raw.monsterType || raw.type || raw.type_label || "";
          const level = Number(fields.level ?? raw.level ?? raw.Level);
          const idRaw = raw.id ?? raw.monsterId ?? raw.name ?? raw.Name ?? fields.name_label ?? "";
          const id = normalizeMonsterId(idRaw || nameRaw);
          return {
            id,
            name: nameRaw ? String(nameRaw) : "Unknown Monster",
            monsterType: monsterTypeRaw === null || monsterTypeRaw === undefined ? "" : String(monsterTypeRaw),
            level: Number.isFinite(level) ? level : null,
          };
        };

        const normalizeMonsters = (list) => {
          if (!Array.isArray(list)) return [];
          return list
            .map((entry) => normalizeMonster(entry))
            .filter(Boolean)
            .filter((monster) => isMonsterAllowed(monster));
        };

        const populateFilters = (data) => {
          const slotOptions = new Map();
          const resistOptions = new Set();

          data.forEach((item) => {
            const slotValue = normalizeFilterValue(item.slot);
            if (slotValue) {
              if (!slotOptions.has(slotValue)) slotOptions.set(slotValue, item.slot);
            }
            const res = item.resistances || {};
            [
              ["fire", res.fire],
              ["poison", res.poison],
              ["cold", res.cold],
              ["disease", res.disease],
              ["acid", res.acid],
              ["electric", res.electric || res.lightning],
            ].forEach(([key, val]) => {
              if (val !== null && val !== undefined && Number(val) !== 0) {
                resistOptions.add(key);
              }
            });
          });

          const slotList = Array.from(slotOptions.entries())
            .sort((a, b) => a[1].localeCompare(b[1]))
            .map(([value, label]) => ({ value, label }));
          const resistLabels = {
            fire: "Fire",
            poison: "Poison",
            cold: "Cold",
            disease: "Disease",
            acid: "Acid",
            electric: "Electric",
          };
          const resistList = Array.from(resistOptions)
            .sort((a, b) => resistLabels[a].localeCompare(resistLabels[b]))
            .map((value) => ({ value, label: resistLabels[value] || value }));

          setOptions(slotFilter, slotList);
          setOptions(resistFilter, resistList);
          if (resistFilter) {
            Array.from(resistFilter.options).forEach((opt) => {
              const color = RESIST_COLORS[opt.value];
              if (color) {
                opt.style.color = color;
              }
            });
          }
        };

        const imageManifestCache = new Map();
        const loadImageManifest = (folder) => {
          if (imageManifestCache.has(folder)) return imageManifestCache.get(folder);
          const map = new Map();
          imageManifestCache.set(folder, map);
          fetch(`images/${folder}/manifest.json`)
            .then((res) => (res.ok ? res.json() : Promise.reject()))
            .then((list) => {
              const entries = Array.isArray(list) ? list : [];
              entries.forEach((path) => {
                const file = String(path || "").split("/").pop() || "";
                const base = file.replace(/\.[^.]+$/, "").toLowerCase();
                if (base) map.set(base, path);
              });
            })
            .catch(() => {});
          return map;
        };

        loadImageManifest("armors");
        loadImageManifest("weapons");

        const deriveImageCandidates = (item, folder = "armors") => {
          const candidates = [];
          const direct = typeof item === "string" ? item : item && item.image;
          if (direct) candidates.push(direct);
          const name = (item && (item.name || item.Name || item.id)) || "";
          const trimmed = String(name).trim();
          const lower = trimmed.toLowerCase();
          const manifest = imageManifestCache.get(folder);
          if (manifest && lower && manifest.has(lower)) {
            candidates.push(manifest.get(lower));
          }
          if (trimmed) {
            const encoded = encodeURIComponent(trimmed);
            candidates.push(`images/${folder}/${encoded}.gif`, `images/${folder}/${encoded}.png`);
          }
          return Array.from(new Set(candidates.filter(Boolean)));
        };

        const ensureImage = (img, fallback, item, folder = "armors") => {
          if (!img || !fallback) return;
          fallback.style.display = "none";
          const sources = deriveImageCandidates(item, folder);
          if (!sources.length) {
            img.style.display = "none";
            fallback.style.display = "flex";
            return;
          }
          let index = 0;
          const trySet = () => {
            img.onload = () => {
              img.style.display = "block";
              fallback.style.display = "none";
            };
            img.onerror = () => {
              index += 1;
              if (index < sources.length) {
                trySet();
              } else {
                img.style.display = "none";
                fallback.style.display = "flex";
              }
            };
            img.src = sources[index];
          };
          trySet();
        };

        const buildHead = () => {
          tableHeadRow.innerHTML = "";
          COLUMNS.forEach((col) => {
            const th = document.createElement("th");
            th.setAttribute("scope", "col");

            const labelSpan = document.createElement("span");
            labelSpan.textContent = col.label;
            const resistKey = col.key.replace(/Resist$/, "").toLowerCase();
            const resistColor = RESIST_COLORS[resistKey];
            if (resistColor) {
              labelSpan.style.color = resistColor;
            }
            th.appendChild(labelSpan);

            th.dataset.sortKey = col.key;
            const indicator = document.createElement("span");
            indicator.className = "sort-indicator";
            indicator.setAttribute("aria-hidden", "true");
            indicator.textContent = "\u2195";
            th.appendChild(indicator);

            th.addEventListener("click", () => {
              if (sortKey === col.key) {
                sortDir = sortDir === "asc" ? "desc" : "asc";
              } else {
                sortKey = col.key;
                sortDir = "asc";
              }
              applyFilterAndSort();
            });
            tableHeadRow.appendChild(th);
          });
          updateSortIndicators();
        };

        const formatRequirement = (requirement) => {
          if (requirement === 2) return "Evil Reputation";
          if (requirement === 6) return "Good Reputation";
          return `Player Level ${formatNumber(requirement)}`;
        };

        const extractPerkBaseName = (value) => {
          const raw = (value || "").toString().trim();
          if (!raw || raw === "-" || raw.toLowerCase() === "none") return "";
          return raw
            .replace(/\s*\(\s*tier\s*\d+\s*\)\s*$/i, "")
            .replace(/\s*\(\s*t\s*\d+\s*\)\s*$/i, "")
            .replace(/\s*tier\s*\d+\s*$/i, "")
            .replace(/\s*t\s*\d+\s*$/i, "")
            .trim();
        };

        const createPerkDetailPill = (value) => {
          const labelText = formatValue(value);
          const baseName = extractPerkBaseName(value);
          if (!labelText || labelText === "-" || !baseName) {
            return createPerkBadge(value);
          }

          const pill = document.createElement("span");
          pill.className = "detail-pill";
          pill.tabIndex = 0;
          pill.setAttribute("aria-label", `${labelText} perk details`);

          const labelSpan = document.createElement("span");
          labelSpan.textContent = labelText;
          const color = getPerkTierColor(value);
          if (color) labelSpan.style.color = color;
          pill.appendChild(labelSpan);

          const tooltip = document.createElement("span");
          tooltip.className = "detail-tooltip perk-tooltip";
          tooltip.role = "tooltip";

          const entry = perkIndexByName.get(baseName.toLowerCase());
          const detailsLines = Array.isArray(entry?.details)
            ? entry.details.map((line) => String(line || "").trim()).filter(Boolean)
            : [];

          const title = document.createElement("div");
          title.className = "perk-tooltip-title";
          title.textContent = labelText;
          tooltip.appendChild(title);

          if (detailsLines.length) {
            const divider = document.createElement("div");
            divider.className = "detail-tooltip-divider";
            tooltip.appendChild(divider);

            detailsLines.forEach((line) => {
              const div = document.createElement("div");
              div.className = "perk-tooltip-line";
              div.textContent = line;
              tooltip.appendChild(div);
            });
          } else {
            const line = document.createElement("div");
            line.className = "perk-tooltip-line";
            line.textContent = "Perk info unavailable.";
            tooltip.appendChild(line);
          }

            pill.appendChild(tooltip);
            return pill;
          };

        const createRarityValuePill = (baseValue, labelText, maxRarity) => {
          const numericBase = Number(baseValue);
          const formattedBase = formatNumber(baseValue);
          if (formattedBase === "-" || !Number.isFinite(numericBase)) {
            return formattedBase;
          }

          const pill = document.createElement("span");
          pill.className = "detail-pill";
          pill.tabIndex = 0;
          pill.setAttribute("aria-label", `${labelText} values by rarity`);

          const labelSpan = document.createElement("span");
          labelSpan.textContent = formattedBase;
          pill.appendChild(labelSpan);

          const tooltip = document.createElement("span");
          tooltip.className = "detail-tooltip";
          tooltip.role = "tooltip";

          const headerRow = document.createElement("div");
          headerRow.className = "detail-tooltip-row";
          const headerLeft = document.createElement("span");
          headerLeft.className = "detail-tooltip-label";
          headerLeft.textContent = "Rarity";
          const headerRight = document.createElement("span");
          headerRight.className = "detail-tooltip-label";
          headerRight.textContent = labelText;
          headerRow.appendChild(headerLeft);
          headerRow.appendChild(headerRight);
          tooltip.appendChild(headerRow);

          const divider = document.createElement("div");
          divider.className = "detail-tooltip-divider";
          tooltip.appendChild(divider);

          const maxIndex = getMaxRarityIndex(maxRarity);
          const list =
            maxIndex === null ? RARITY_MULTIPLIERS : RARITY_MULTIPLIERS.slice(0, maxIndex + 1);
          list.forEach((rarity) => {
            const row = document.createElement("div");
            row.className = "detail-tooltip-row";
            const raritySpan = document.createElement("span");
            raritySpan.textContent = rarity.label;
            const valueSpan = document.createElement("span");
            valueSpan.textContent = formatNumber(numericBase * rarity.multiplier);
            row.appendChild(raritySpan);
            row.appendChild(valueSpan);
            tooltip.appendChild(row);
          });

          pill.appendChild(tooltip);
          return pill;
        };

        const getMonsterDropRange = (monsterLevel) => {
          const level = Number(monsterLevel);
          if (!Number.isFinite(level)) return null;
          return {
            level,
            min: Math.max(0, level - 5),
            max: level + 5,
          };
        };

        const createDropsFromPill = (item) => {
          const pill = document.createElement("span");
          pill.className = "detail-pill";
          pill.textContent = "Monsters";
          pill.tabIndex = 0;
          pill.setAttribute("aria-label", "Monsters that drop this item");

          const tooltip = document.createElement("span");
          tooltip.className = "detail-tooltip";
          tooltip.role = "tooltip";

            if (!Array.isArray(monsters) || !monsters.length) {
              tooltip.textContent = "No monster data loaded";
            } else {
              const itemLevel = Number(item?.level);
              const uniqueMonsterIds = UNIQUE_ARMOR_DROP_SOURCES[normalizeFilterValue(item?.name)] || null;
              const useUnique = Array.isArray(uniqueMonsterIds) && uniqueMonsterIds.length > 0;
              if (!useUnique && !Number.isFinite(itemLevel)) {
                tooltip.textContent = "No level data";
              } else {
                const uniqueSet = useUnique ? new Set(uniqueMonsterIds.map((id) => normalizeMonsterId(id))) : null;
                const list = monsters
                  .map((monster) => {
                    const monsterId = normalizeMonsterId(monster.name || monster.id);
                    if (useUnique) {
                      if (!uniqueSet.has(monsterId)) return null;
                    } else {
                      const range = getMonsterDropRange(monster.level);
                      if (!range) return null;
                      if (itemLevel < range.min || itemLevel > range.max) return null;
                    }
                    const typeRaw = monster.monsterType || "";
                    const levelValue = Number(monster.level);
                    return {
                      id: monsterId,
                      name: monster.name || "Unknown Monster",
                      type: typeRaw,
                      typeKey: normalizeFilterValue(typeRaw) || "unknown",
                      level: Number.isFinite(levelValue) ? levelValue : null,
                    };
                  })
                  .filter(Boolean)
                  .sort((a, b) => {
                    if (a.typeKey !== b.typeKey) return a.typeKey.localeCompare(b.typeKey);
                    const levelA = Number.isFinite(a.level) ? a.level : -Infinity;
                    const levelB = Number.isFinite(b.level) ? b.level : -Infinity;
                    if (levelB !== levelA) return levelB - levelA;
                    return a.name.localeCompare(b.name);
                  });

              const headerRow = document.createElement("div");
              headerRow.className = "detail-tooltip-row";
              const nameLabel = document.createElement("span");
              nameLabel.className = "detail-tooltip-label";
              nameLabel.textContent = "Name";
              const typeLabel = document.createElement("span");
              typeLabel.className = "detail-tooltip-label";
              typeLabel.textContent = "Type";
              headerRow.appendChild(nameLabel);
              headerRow.appendChild(typeLabel);
              tooltip.appendChild(headerRow);

              const divider = document.createElement("div");
              divider.className = "detail-tooltip-divider";
              tooltip.appendChild(divider);

                if (!list.length) {
                  const emptyRow = document.createElement("div");
                  emptyRow.className = "detail-tooltip-row";
                  const emptyLabel = document.createElement("span");
                  emptyLabel.className = "detail-tooltip-label";
                  emptyLabel.textContent = "No monsters in range";
                  emptyRow.appendChild(emptyLabel);
                  tooltip.appendChild(emptyRow);
                } else {
                  let lastTypeKey = null;
                  list.forEach((entry) => {
                    if (lastTypeKey && entry.typeKey !== lastTypeKey) {
                      const groupDivider = document.createElement("div");
                      groupDivider.className = "detail-tooltip-divider";
                      tooltip.appendChild(groupDivider);
                    }
                    lastTypeKey = entry.typeKey;

                    const row = document.createElement("div");
                    row.className = "detail-tooltip-row";
                    const nameLink = document.createElement("a");
                    nameLink.textContent = entry.name;
                    nameLink.href = `pages/enemies/monsters.html?monster=${encodeURIComponent(entry.id)}`;
                    const typeSpan = document.createElement("span");
                    typeSpan.className = "detail-tooltip-type";
                    typeSpan.textContent = formatMonsterTypeLabel(entry.type);
                    row.appendChild(nameLink);
                    row.appendChild(typeSpan);
                    tooltip.appendChild(row);
                  });
                }
              }
            }

          pill.appendChild(tooltip);
          return pill;
        };

        let pinnedTooltip = null;
        let pinDocumentListenerAttached = false;

        function unpinTooltip(tooltip) {
          if (!tooltip) return;
          tooltip.classList.remove("is-pinned");
          if (pinnedTooltip === tooltip) pinnedTooltip = null;
        }

        function attachTooltipPinning(root) {
          const scope = root || document;
          const tooltips = scope.querySelectorAll(".detail-pill .detail-tooltip");
          tooltips.forEach((tooltip) => {
            if (!tooltip || tooltip.dataset.pinWired === "1") return;
            const pill = tooltip.closest(".detail-pill");
            if (!pill) return;

            const toggle = (event) => {
              event.preventDefault();
              event.stopPropagation();
              if (pinnedTooltip && pinnedTooltip !== tooltip) {
                unpinTooltip(pinnedTooltip);
              }
              if (tooltip.classList.contains("is-pinned")) {
                unpinTooltip(tooltip);
              } else {
                tooltip.classList.add("is-pinned");
                pinnedTooltip = tooltip;
              }
            };

            pill.addEventListener("click", toggle);
            pill.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                toggle(event);
              }
            });
            tooltip.addEventListener("click", (event) => event.stopPropagation());
            tooltip.dataset.pinWired = "1";
          });

          if (!pinDocumentListenerAttached) {
            pinDocumentListenerAttached = true;
            document.addEventListener("click", (event) => {
              if (!pinnedTooltip) return;
              const pill = pinnedTooltip.closest(".detail-pill");
              if (pill && pill.contains(event.target)) return;
              unpinTooltip(pinnedTooltip);
            });
            document.addEventListener("keydown", (event) => {
              if (event.key !== "Escape") return;
              if (!pinnedTooltip) return;
              unpinTooltip(pinnedTooltip);
            });
          }
        }

        const setDetails = (item) => {
          if (!item) return;
          detailFields.name.textContent = item.name || "Unknown";
          ensureImage(detailFields.image, detailFields.imageFallback, item, "armors");
          if (pinnedTooltip) unpinTooltip(pinnedTooltip);

          const container = detailFields.properties;
          container.innerHTML = "";

          addRow(
            container,
            [
              ["Slot", formatValue(item.slot)],
              ["Level", formatNumber(item.level)],
              ["Armor", formatNumber(item.armor)],
              ["Weight", formatNumber(item.weight)],
              ["To Hit", formatNumber(item.toHit)],
            ],
            5
          );

          addDivider(container);

          addRow(
            container,
            [
              ["Strength", formatNumber((item.stats && item.stats.strength) ?? 0)],
              ["Constitution", formatNumber((item.stats && item.stats.constitution) ?? 0)],
              ["Dexterity", formatNumber((item.stats && item.stats.dexterity) ?? 0)],
            ],
            3
          );

          addDivider(container);

          const res = item.resistances || {};
          const makeResistEntry = (key, labelText, rawValue) => {
            const color = RESIST_COLORS[key];
            const labelSpan = document.createElement("span");
            labelSpan.textContent = labelText;
            if (color) labelSpan.style.color = color;
            const valueSpan = document.createElement("span");
            valueSpan.textContent = formatNumber(rawValue ?? 0);
            if (color) valueSpan.style.color = color;
            return [labelSpan, valueSpan];
          };
          addRow(
            container,
            [
              makeResistEntry("fire", "Fire", res.fire),
              makeResistEntry("poison", "Poison", res.poison),
              makeResistEntry("cold", "Cold", res.cold),
            ],
            3
          );
          addRow(
            container,
            [
              makeResistEntry("disease", "Disease", res.disease),
              makeResistEntry("acid", "Acid", res.acid),
              makeResistEntry("electric", "Electric", res.lightning ?? res.electric),
            ],
            3
          );

          addDivider(container);

          addRow(
            container,
            [
              ["Innate Perk", createPerkDetailPill(item.perk)],
              ["Corrupted Perk", createPerkDetailPill(item.corruptedPerk)],
            ],
            2
          );

          addDivider(container);

          addRow(
            container,
            [
              ["Max Rarity", formatValue(item.maxRarity)],
              [
                "Deconstruction",
                createRarityValuePill(item.deconstruction, "Deconstruction", item.maxRarity),
              ],
              ["Promotion", createRarityValuePill(item.promotion, "Promotion", item.maxRarity)],
            ],
            3
          );

          addDivider(container);

            addRow(
              container,
              [["Requirement", formatRequirement(item.playerLevelRequirement)]],
              1
            );

            addDivider(container);

            addRow(container, [["Drops From", createDropsFromPill(item)]], 1);

            addDivider(container);

            addRow(
              container,
              [
                ["Sell Value", formatNumber(item.sellValue, { maximumFractionDigits: 2 })],
                ["Buy Value", formatNumber(item.value)],
            ],
            2
          );

          attachTooltipPinning(details);
          details.classList.add("show");
          details.scrollIntoView({ behavior: "smooth", block: "start" });
        };

        const clearDetails = () => {
          details.classList.remove("show");
          if (pinnedTooltip) unpinTooltip(pinnedTooltip);
        };

        const renderTable = (rows) => {
          if (!rows.length) {
            renderEmpty("No armors match your filters.");
            return;
          }

          const fragment = document.createDocumentFragment();

          rows.forEach((item) => {
            const tr = document.createElement("tr");
            tr.dataset.id = item.id || "";

            COLUMNS.forEach((col) => {
              const td = document.createElement("td");
              const value = item[col.key];
              if (col.key === "image") {
                const img = document.createElement("img");
                img.className = "item-thumb";
                img.alt = `${item.name || "Item"} image`;
                const fallback = document.createElement("span");
                fallback.className = "no-image";
                fallback.textContent = "No Image";
                ensureImage(img, fallback, item, "armors");
                td.appendChild(img);
                td.appendChild(fallback);
              } else if (col.format) {
                td.textContent = col.format(value);
              } else {
                td.textContent = formatValue(value);
              }
              const resistKey = col.key.replace(/Resist$/, "").toLowerCase();
              const resistColor = RESIST_COLORS[resistKey];
              if (resistColor) {
                td.style.color = resistColor;
              }
              tr.appendChild(td);
            });

            tr.addEventListener("click", () => setDetails(item));
            fragment.appendChild(tr);
          });

          tableBody.innerHTML = "";
          tableBody.appendChild(fragment);
          maybeSelectPendingArmor(rows);
        };

        const maybeSelectPendingArmor = (list) => {
          if (!pendingArmorName) return;
          const match = (list || items).find((a) => getArmorId(a) === pendingArmorName);
          if (!match) return;
          pendingArmorName = "";
          setDetails(match);
        };

        const applyFilterAndSort = () => {
          if (!Array.isArray(items) || !items.length) {
            renderEmpty("No armors found in armors_data06.json.");
            return;
          }

          const filtered = items.filter((item) => {
            const matchesSlot = selectedSlots.size === 0 || selectedSlots.has(normalizeFilterValue(item.slot));
            if (!matchesSlot) return false;

            if (selectedResists.size) {
              const res = item.resistances || {};
              const resMap = {
                fire: res.fire,
                poison: res.poison,
                cold: res.cold,
                disease: res.disease,
                acid: res.acid,
                electric: res.electric || res.lightning,
              };
              const hasAll = Array.from(selectedResists).every(
                (key) => resMap[key] !== null && resMap[key] !== undefined && Number(resMap[key]) !== 0
              );
              if (!hasAll) return false;
            }

            if (!searchTerm) return true;
            const text = [
              ...COLUMNS.map((col) => formatValue(item[col.key])),
              formatValue(item.perk),
              formatValue(item.corruptedPerk),
            ]
              .join(" ")
              .toLowerCase();
            return text.includes(searchTerm.toLowerCase());
          });

          const sorted = filtered.sort((a, b) => {
            const av = normalizeSortValue(a[sortKey]);
            const bv = normalizeSortValue(b[sortKey]);
            if (av < bv) return sortDir === "asc" ? -1 : 1;
            if (av > bv) return sortDir === "asc" ? 1 : -1;
            return 0;
          });

          updateSortIndicators();

          if (countLabel) {
            const count = sorted.length;
            countLabel.textContent = `${count} result${count === 1 ? "" : "s"}`;
          }

          renderTable(sorted);
        };

          const init = () => {
            Promise.all([
              fetchJsonCached(dataUrl.toString()),
              fetchJsonCached(perksUrl),
              fetchJsonCached(monstersUrl),
              loadAllowlists(),
            ])
              .then(([data, perksData, monstersData, allowlists]) => {
                const perks = Array.isArray(perksData?.perks) ? perksData.perks : [];
                perkIndexByName = new Map();
                perks.forEach((entry) => {
                  const name = entry && typeof entry.name === "string" ? entry.name.trim() : "";
                  if (!name) return;
                  perkIndexByName.set(name.toLowerCase(), entry);
                });
                applyAllowlists(allowlists);
                monsters = normalizeMonsters(Array.isArray(monstersData) ? monstersData : []);
                items = (Array.isArray(data) ? data : [])
                  .map((row) => normalizeArmor(row))
                  .filter(
                    (row) => row && !hiddenArmorNames.has((row.name || "").toLowerCase()) && !isSlotZero(row.slot)
                  );
              if (!items.length) {
                renderEmpty("Add armors_data06.json beside this page to see armors.");
                return;
              }
              sortKey = "level";
              sortDir = "desc";
              buildHead();
              populateFilters(items);
              if (initialArmorSearchTerm) {
                searchTerm = initialArmorSearchTerm;
                if (searchInput) searchInput.value = initialArmorSearchTerm;
              }
              applyFilterAndSort();
            })
            .catch(() => {
              renderEmpty("Unable to load armors. Add armors_data06.json beside this page.");
            });
        };

        if (searchInput) {
          searchInput.addEventListener("input", (event) => {
            searchTerm = event.target.value || "";
            applyFilterAndSort();
          });
        }

        if (slotFilter) {
          enableToggleSelect(slotFilter);
          slotFilter.addEventListener("change", () => {
            selectedSlots = new Set(Array.from(slotFilter.selectedOptions).map((o) => o.value));
            applyFilterAndSort();
          });
        }

        if (resistFilter) {
          enableToggleSelect(resistFilter);
          resistFilter.addEventListener("change", () => {
            selectedResists = new Set(Array.from(resistFilter.selectedOptions).map((o) => o.value));
            applyFilterAndSort();
          });
        }

        if (closeBtn) {
          closeBtn.addEventListener("click", clearDetails);
        }

        init();
      })();
    </script>
  </body>
</html>
