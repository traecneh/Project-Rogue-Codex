<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Experience Pool System &mdash; Project Rogue Codex</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <base href="../../" />
    <link rel="icon" type="image/x-icon" href="images/project-rogue-favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="images/project-rogue-favicon-32.png" />
    <link rel="icon" type="image/png" sizes="64x64" href="images/project-rogue-favicon-64.png" />
    <link rel="icon" type="image/png" sizes="180x180" href="images/project-rogue-favicon-180.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="images/project-rogue-favicon-512.png" />
    <link rel="stylesheet" href="css/styles.css" />
    <script src="js/nav-loader.js" defer></script>
  </head>
  <body>
    <div class="layout">
      <div id="sidebar-root"></div>
      <main class="main-content">
        <header class="content-header">
          <h1 class="content-title">Experience Pool System</h1>
          <p class="content-tagline">Passive levels that build in the background and double XP while you hunt.</p>
        </header>

        <article class="content-section">
          <h2>How the Pool Builds</h2>
          <p>The Experience Pool is a small reserve of bonus levels that ticks up automatically:</p>
          <ul>
            <li>Levels <strong>1&ndash;89</strong>: earns <strong>+3.0 levels per 24 hours</strong>, up to a <strong>3.0 level cap</strong>.</li>
            <li>Levels <strong>90+</strong>: slows to <strong>+1.0 level per 24 hours</strong> and the cap shrinks to <strong>1.0 stored level</strong>.</li>
            <li>If you’re below the cap, the pool keeps filling; once capped it pauses until you spend XP.</li>
          </ul>
        </article>

        <article class="content-section">
          <h2>How It Works In Combat</h2>
          <ul>
            <li>When you have pool stored, all XP you earn from hunting is doubled.</li>
            <li>Each <strong>1% of a level</strong> you gain consumes <strong>0.01</strong> from the pool.</li>
            <li>Example: earning <strong>25%</strong> of a level spends <strong>0.25</strong> pool.</li>
          </ul>
          <p>Once the pool empties, XP returns to its normal rate until the bank refills.</p>
        </article>

        <article class="content-section">
          <h2>Why It Exists</h2>
          <ul>
            <li>Lets players with limited playtime bank progress and catch up quickly when they log in.</li>
            <li>Rewards actual gameplay: you still need to hunt to convert stored pool into real XP.</li>
            <li>Plays nicely with future seasonal "catch-up" mechanics by front-loading some bonus levels.</li>
          </ul>
        </article>

        <article class="content-section" id="experience-pool-sim">
          <h2>Experience Pool Simulator</h2>
          <p>
            Pick a level, your current XP toward the next level, and your stored pool. Start the simulator to watch
            randomized kills (250&ndash;350 XP every 1.5s) consume the pool, double your XP, and push you toward the next level.
          </p>
          <div class="stat-widget xp-sim-widget">
            <div class="stat-control">
              <label for="xp-sim-level">Level: <span data-xp-level>70</span></label>
              <input type="range" id="xp-sim-level" min="1" max="105" value="70" />
            </div>
            <div class="stat-control">
              <label for="xp-sim-current-xp">
                Current XP:
                <span data-xp-current>0</span> /
                <span data-xp-needed>2,000</span>
              </label>
              <input type="range" id="xp-sim-current-xp" min="0" value="0" step="100" />
            </div>
            <div class="stat-control">
              <label for="xp-sim-pool">
                Experience Pool:
                <span data-xp-pool>0.00</span> levels
              </label>
              <input type="range" id="xp-sim-pool" min="0" max="3" step="0.01" value="0" />
            </div>
            <div class="xp-sim-buttons">
              <button type="button" data-xp-start>Start Simulation</button>
              <button type="button" data-xp-stop disabled>Stop</button>
            </div>
            <div class="xp-sim-metrics">
              <p><strong>Last Base XP:</strong> <span data-xp-base>0</span></p>
              <p><strong>Pool Bonus:</strong> <span data-xp-bonus>0</span></p>
              <p><strong>Total XP Gain:</strong> <span data-xp-total>0</span></p>
              <p><strong>Pool Remaining:</strong> <span data-xp-pool-remaining>0.00</span> levels</p>
              <p><strong>Progress:</strong> <span data-xp-progress>0%</span></p>
              <p><strong>Est. Time to Level:</strong> <span data-xp-eta>&mdash;</span></p>
            </div>
          </div>
        </article>
      </main>
    </div>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const XP_THRESHOLDS = [
          2000, 4000, 6000, 8000, 10000, 15000, 20000, 25000, 30000, 40000, 50000, 60000, 80000, 100000, 120000, 140000,
          160000, 200000, 300000, 400000, 500000, 600000, 750000, 1000000, 1250000, 1500000, 1750000, 2000000, 2250000,
          2500000, 2750000, 3000000, 3500000, 4000000, 4500000, 5000000, 5500000, 6000000, 7000000, 8000000, 9000000,
          10000000, 11000000, 12000000, 13000000, 14000000, 15000000, 16000000, 17000000, 18000000, 19000000, 20000000,
          21000000, 22000000, 23000000, 24000000, 26000000, 28000000, 30000000, 32000000, 34000000, 36000000, 38000000,
          40000000, 42000000, 44000000, 46000000, 48000000, 51000000, 54000000, 57000000, 60000000, 63000000, 66000000,
          69000000, 72000000, 75000000, 78000000, 81000000, 84000000, 87000000, 90000000, 93000000, 96000000, 100000000,
          104000000, 108000000, 113000000, 118000000, 123000000, 128000000, 133000000, 138000000, 143000000, 148000000,
          153000000, 160000000, 168000000, 178000000, 350000000, 700000000, 1050000000, 1400000000, 1750000000
        ];

        const levelInput = document.getElementById("xp-sim-level");
        const xpInput = document.getElementById("xp-sim-current-xp");
        const poolInput = document.getElementById("xp-sim-pool");
        const startButton = document.querySelector("[data-xp-start]");
        const stopButton = document.querySelector("[data-xp-stop]");
        const levelLabel = document.querySelector("[data-xp-level]");
        const xpCurrentLabel = document.querySelector("[data-xp-current]");
        const xpNeededLabel = document.querySelector("[data-xp-needed]");
        const poolLabel = document.querySelector("[data-xp-pool]");
        const baseLabel = document.querySelector("[data-xp-base]");
        const bonusLabel = document.querySelector("[data-xp-bonus]");
        const totalLabel = document.querySelector("[data-xp-total]");
        const poolRemainingLabel = document.querySelector("[data-xp-pool-remaining]");
        const progressLabel = document.querySelector("[data-xp-progress]");
        const etaLabel = document.querySelector("[data-xp-eta]");

        if (
          !levelInput ||
          !xpInput ||
          !poolInput ||
          !startButton ||
          !stopButton ||
          !levelLabel ||
          !xpCurrentLabel ||
          !xpNeededLabel ||
          !poolLabel ||
          !baseLabel ||
          !bonusLabel ||
          !totalLabel ||
          !poolRemainingLabel ||
          !progressLabel ||
          !etaLabel
        ) {
          return;
        }

        const state = {
          level: Number(levelInput.value) || 1,
          xp: Number(xpInput.value) || 0,
          pool: Number(poolInput.value) || 0
        };

        let simIntervalId = null;
        let simStartTimestamp = 0;
        let simAccumulatedXp = 0;

        const formatNumber = (value) => Number(value || 0).toLocaleString();

        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

        const getXpNeeded = (level) => {
          if (level < 1 || level > XP_THRESHOLDS.length) return null;
          const nextRequirement = XP_THRESHOLDS[level - 1];
          const currentRequirement = level > 1 ? XP_THRESHOLDS[level - 2] : 0;
          return nextRequirement - currentRequirement;
        };

        const getPoolCap = (level) => (level >= 90 ? 1 : 3);

        const formatDuration = (seconds) => {
          if (!isFinite(seconds) || seconds <= 0) return "—";
          const totalSeconds = Math.ceil(seconds);
          const hours = Math.floor(totalSeconds / 3600);
          const minutes = Math.floor((totalSeconds % 3600) / 60);
          const secs = totalSeconds % 60;
          if (hours > 0) {
            return `${hours}h ${minutes}m`;
          }
          if (minutes > 0) {
            return `${minutes}m ${secs}s`;
          }
          return `${secs}s`;
        };

        const syncPoolSliderBounds = () => {
          const cap = getPoolCap(state.level);
          poolInput.max = String(cap);
          if (state.pool > cap) {
            state.pool = cap;
          }
        };

        const syncXpSliderBounds = () => {
          const xpNeeded = getXpNeeded(state.level);
          if (xpNeeded) {
            xpInput.disabled = false;
            xpInput.max = String(xpNeeded);
            const step = Math.max(1, Math.round(xpNeeded / 400));
            xpInput.step = String(step);
            if (state.xp > xpNeeded) {
              state.xp = xpNeeded - step;
            }
          } else {
            xpInput.disabled = true;
            state.xp = 0;
          }
        };

        const normalizeState = () => {
          while (true) {
            const xpNeeded = getXpNeeded(state.level);
            if (!xpNeeded) {
              state.xp = 0;
              break;
            }
            if (state.xp >= xpNeeded) {
              state.xp -= xpNeeded;
              state.level += 1;
            } else if (state.xp < 0) {
              state.xp = 0;
              break;
            } else {
              break;
            }
          }
        };

        const updateLabels = () => {
          const xpNeeded = getXpNeeded(state.level);
          levelLabel.textContent = state.level.toString();
          xpCurrentLabel.textContent = formatNumber(Math.floor(state.xp));
          xpNeededLabel.textContent = xpNeeded ? formatNumber(xpNeeded) : "Max";
          poolLabel.textContent = state.pool.toFixed(2);
          poolRemainingLabel.textContent = `${state.pool.toFixed(2)}`;
          if (xpNeeded) {
            const percent = Math.min(100, (state.xp / xpNeeded) * 100);
            progressLabel.textContent = `${percent.toFixed(1)}%`;
          } else {
            progressLabel.textContent = "Max level";
          }
        };

        const updateInputs = () => {
          levelInput.value = String(state.level);
          xpInput.value = String(Math.max(0, Math.round(state.xp)));
          poolInput.value = state.pool.toFixed(2);
        };

        const syncButtons = () => {
          const hasNextLevel = Boolean(getXpNeeded(state.level));
          startButton.disabled = Boolean(simIntervalId) || !hasNextLevel;
          stopButton.disabled = !simIntervalId;
        };

        const updateEta = () => {
          if (!simStartTimestamp || simAccumulatedXp <= 0 || !simIntervalId) {
            etaLabel.textContent = "—";
            return;
          }
          const xpNeeded = getXpNeeded(state.level);
          if (!xpNeeded) {
            etaLabel.textContent = "Max level";
            return;
          }
          const xpRemaining = xpNeeded - state.xp;
          if (xpRemaining <= 0) {
            etaLabel.textContent = "Level up imminent";
            return;
          }
          const elapsedSeconds = (performance.now() - simStartTimestamp) / 1000;
          if (elapsedSeconds <= 0) {
            etaLabel.textContent = "—";
            return;
          }
          const xpPerSecond = simAccumulatedXp / elapsedSeconds;
          if (xpPerSecond <= 0) {
            etaLabel.textContent = "—";
            return;
          }
          const seconds = xpRemaining / xpPerSecond;
          etaLabel.textContent = formatDuration(seconds);
        };

        const applyExperienceGain = (gain) => {
          state.xp += gain;
          while (true) {
            const xpNeeded = getXpNeeded(state.level);
            if (!xpNeeded) {
              state.xp = 0;
              break;
            }
            if (state.xp >= xpNeeded) {
              state.xp -= xpNeeded;
              state.level += 1;
            } else {
              break;
            }
          }
        };

        const runSimulationTick = () => {
          const xpNeeded = getXpNeeded(state.level);
          if (!xpNeeded) {
            stopSimulation();
            return;
          }

          const baseGain = randomInt(250, 350);
          const percentGain = (baseGain / xpNeeded) * 100;
          let bonusGain = 0;
          if (state.pool > 0 && percentGain > 0) {
            const poolPercentAvailable = state.pool * 100;
            const percentFromPool = Math.min(poolPercentAvailable, percentGain);
            bonusGain = baseGain * (percentFromPool / percentGain);
            state.pool = Math.max(0, state.pool - percentFromPool / 100);
          }

          const totalGain = baseGain + bonusGain;
          simAccumulatedXp += totalGain;
          applyExperienceGain(totalGain);

          syncPoolSliderBounds();
          syncXpSliderBounds();
          updateLabels();
          updateInputs();
          syncButtons();
          baseLabel.textContent = formatNumber(Math.round(baseGain));
          bonusLabel.textContent = formatNumber(Math.round(bonusGain));
          totalLabel.textContent = formatNumber(Math.round(totalGain));
          poolRemainingLabel.textContent = state.pool.toFixed(2);
          updateEta();
        };

        const startSimulation = () => {
          if (simIntervalId || !getXpNeeded(state.level)) return;
          simStartTimestamp = performance.now();
          simAccumulatedXp = 0;
          simIntervalId = setInterval(runSimulationTick, 1500);
          syncButtons();
        };

        const stopSimulation = () => {
          if (!simIntervalId) {
            syncButtons();
            return;
          }
          clearInterval(simIntervalId);
          simIntervalId = null;
          syncButtons();
        };

        levelInput.addEventListener("input", () => {
          stopSimulation();
          state.level = Number(levelInput.value) || 1;
          normalizeState();
          syncPoolSliderBounds();
          syncXpSliderBounds();
          updateLabels();
          updateInputs();
          syncButtons();
        });

        xpInput.addEventListener("input", () => {
          stopSimulation();
          state.xp = Number(xpInput.value) || 0;
          normalizeState();
          syncPoolSliderBounds();
          syncXpSliderBounds();
          updateLabels();
          updateInputs();
          syncButtons();
        });

        poolInput.addEventListener("input", () => {
          stopSimulation();
          const cap = getPoolCap(state.level);
          state.pool = Math.min(cap, Math.max(0, Number(poolInput.value) || 0));
          poolLabel.textContent = state.pool.toFixed(2);
          poolInput.value = state.pool.toFixed(2);
          syncButtons();
        });

        startButton.addEventListener("click", startSimulation);
        stopButton.addEventListener("click", stopSimulation);

        // Initial setup
        normalizeState();
        syncPoolSliderBounds();
        syncXpSliderBounds();
        updateLabels();
        updateInputs();
        syncButtons();
        baseLabel.textContent = "0";
        bonusLabel.textContent = "0";
        totalLabel.textContent = "0";
        etaLabel.textContent = "—";
      });
    </script>
  </body>
</html>
